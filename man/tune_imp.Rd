% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tune_imp.R
\name{tune_imp}
\alias{tune_imp}
\title{Tune Parameters for \code{SlideKnn}/\code{knn_imp} Imputation}
\usage{
tune_imp(
  obj,
  parameters,
  .f = "SlideKnn",
  rep = 1,
  num_na = 100,
  max_iter = 1000,
  .progress = FALSE,
  rowmax = 0.9,
  colmax = 0.9,
  cores = 1
)
}
\arguments{
\item{obj}{A numeric matrix with \strong{samples in rows} and \strong{features in columns}. Note: keep \code{obj} small since
this function doesn't support \code{bigmemory}.}

\item{parameters}{A data frame specifying the parameter combinations to tune. Duplicated rows are removed.
The required columns depend on \code{.f}; see \code{\link[=knn_imp]{knn_imp()}} or \code{\link[=SlideKnn]{SlideKnn()}} for details about the parameters, and \verb{@details} for custom functions.}

\item{.f}{The imputation function to tune. Can be the string "SlideKnn" (default), "knn_imp", or a custom function.}

\item{rep}{The number of repetitions for injecting missing values to evaluate each combination of parameters. Default is 1.}

\item{num_na}{The number of missing values used to estimate prediction quality. Must be a positive integer.}

\item{max_iter}{Maximum number of iterations to attempt finding valid NA positions (default: 1000).}

\item{.progress}{Logical; if TRUE, show a progress bar. Default is FALSE.}

\item{rowmax}{Numeric between 0 and 1 specifying the maximum allowable proportion of missing values in any row. If exceeded, the function stops with an error.}

\item{colmax}{Numeric between 0 and 1 specifying the threshold proportion of missing values in a column above which the column is imputed using the mean instead of k-NN.}

\item{cores}{Integer specifying the number of cores to use for parallel computation of distances.}
}
\description{
This function tunes the parameters for the \code{\link[=SlideKnn]{SlideKnn()}}/\code{\link[=knn_imp]{knn_imp()}} imputation method by injecting missing values
into the dataset multiple times and evaluating the imputation performance for different parameter
combinations. Can also tune custom imputation functions. See details.
}
\details{
This function allows tuning of hyperparameters for matrix imputation methods, including the built-in 'SlideKnn' and 'knn_imp',
or a custom function provided to \code{.f}.

For a custom function in \code{.f}, the \code{parameters} data.frame must have columns whose names match the argument names of \code{.f}
(excluding \code{obj}). The custom function must take \code{obj} as its first input argument and output an imputed numeric matrix
of the same dimensions as \code{obj}.

For the built-in methods ('SlideKnn' or 'knn_imp'), certain parameters are required in \code{parameters} (e.g., \code{n_feat}, \code{k}, \code{n_overlap} for 'SlideKnn';
\code{k} for 'knn_imp'), and defaults are set if not provided (e.g., \code{method = "euclidean"}, \code{post_imp = FALSE}).

\code{tune_imp} can be parallelize over iterations (number of rows of \code{parameters} * number of repetitions per row) with
the argument \code{cores}. Note that for \code{SlideKnn}, \code{tune_imp} will run sequentially but cores will parallelize within
\code{SlideKnn}.

The output is a tibble with columns for each parameter combination, a \code{param_set} identifier, the repetition number (\code{rep}),
and a nested \code{results} column containing a tibble of \code{truth} (original values) and \code{estimate} (imputed values) for the injected NAs.
Metrics can be computed from these results, as shown in the examples.
}
\examples{
data(khanmiss1)

parameters <- data.frame(
  n_feat = c(100, 100, 100),
  k = c(5, 10, 10),
  n_overlap = c(10, 10, 10),
  method = "euclidean",
  # Set post_imp to FALSE to estimate just the k-NN imputation quality
  post_imp = FALSE
)

set.seed(1234)
# Tune `SlideKnn` function on a subset of khanmiss1
obj <- t(khanmiss1)[1:30, sample.int(nrow(khanmiss1), size = 200)]
anyNA(obj)
results <- tune_imp(obj, parameters, rep = 1)

# # Install `{yardstick}` or calculate any other metrics using the result
# library(yardstick)
# met_set <- metric_set(mae, rmse, rsq)
# results$metrics <- lapply(
# results$results,
# function(x) {
# met_set(x, truth = truth, estimate = estimate)
# }
# )
# # Unnest the metrics
# tidyr::unnest(dplyr::select(results, -results), cols = "metrics")

}
\seealso{
\code{\link[=knn_imp]{knn_imp()}}, \code{\link[=SlideKnn]{SlideKnn()}}
}
