% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tune_imp.R
\name{tune_imp}
\alias{tune_imp}
\title{Tune Parameters for Imputation Methods}
\usage{
tune_imp(
  obj,
  parameters,
  .f = "knn_imp",
  rep = 1,
  num_na = 100,
  rowmax = 0.9,
  colmax = 0.9,
  check_sd = FALSE,
  max_iter = 1000,
  .progress = FALSE,
  cores = 1
)
}
\arguments{
\item{obj}{A numeric matrix with \strong{samples in rows} and \strong{features in columns}.}

\item{parameters}{Data frame of parameter combinations to tune where each column is
a parameter accepted by \code{.f}. Duplicates are removed. Supports list columns.}

\item{.f}{Imputation function: "knn_imp" (default), "slide_imp", "pca_imp", or custom function.}

\item{rep}{Number of repetitions for random \code{NA} injection, or list of integer
positions per repetition (if \code{rep} is list then ignores \code{num_na}).}

\item{num_na}{The number of missing values used to estimate prediction quality.}

\item{rowmax}{Number between 0 to 1. NA injection cannot create rows with more missing \% than this number.}

\item{colmax}{Number between 0 to 1. NA injection cannot create cols with more missing \% than this number.}

\item{check_sd}{Check if after NA injections zero variance columns are created or not.}

\item{max_iter}{Maximum number of iterations to attempt finding valid NA positions (default: 1000).}

\item{.progress}{Show progress bar (default FALSE).}

\item{cores}{Number of cores for parallelization (default 1).}
}
\value{
Tibble with parameter columns, \code{param_set} (ID), \code{rep} (repetition), and \code{result} (nested tibble of \code{truth} and \code{estimate}).
}
\description{
Tunes hyperparameters for imputation methods like \code{\link[=slide_imp]{slide_imp()}}, \code{\link[=knn_imp]{knn_imp()}}, \code{\link[=pca_imp]{pca_imp()}},
or custom functions by injecting missing values into the dataset and evaluating
performance across parameter combinations.
}
\details{
Supports tuning built-in methods ('slide_imp', 'knn_imp', 'pca_imp') or custom functions via \code{.f}.

For custom \code{.f}, \code{parameters} columns must match \code{.f}'s arguments (excluding \code{obj}). The
function must take \code{obj} as an argument and return a numeric matrix of the same dimensions.
}
\examples{
data(khanmiss1)

parameters <- data.frame(
  n_feat = c(100, 100, 100),
  k = c(5, 10, 10),
  n_overlap = c(10, 10, 10)
)

set.seed(1234)
obj <- t(khanmiss1)[1:20, sample.int(nrow(khanmiss1), size = 200)]

# Random NA injection
results <- tune_imp(obj, parameters, .f = "slide_imp", rep = 1, num_na = 20)

# Specific NA positions
obj_complete <- obj
obj_complete[is.na(obj_complete)] <- 0
# 3 reps (list of length 3), where each rep has different, but pre-specified locations.
na_positions <- list(
  sample(1:length(obj_complete), 20, replace = FALSE),
  sample(1:length(obj_complete), 20, replace = FALSE),
  sample(1:length(obj_complete), 20, replace = FALSE)
)
results_fixed <- tune_imp(
  obj_complete,
  data.frame(k = 10),
  .f = "knn_imp",
  rep = na_positions
)

# Custom imputation
custom_imp <- function(obj, mean = 0, sd = 1) {
  na_pos <- is.na(obj)
  obj[na_pos] <- rnorm(sum(na_pos), mean = mean, sd = sd)
  obj
}
parameters_custom <- data.frame(mean = c(0, 0, 1), sd = c(1, 2, 1))
results_custom <- tune_imp(
  obj,
  parameters_custom,
  .f = custom_imp,
  rep = 1,
  num_na = 20
)

# Analyze the results with yardstick
\dontshow{if (requireNamespace("dplyr", quietly = TRUE) && requireNamespace("yardstick", quietly = TRUE) && requireNamespace("tidyr", quietly = TRUE)) withAutoprint(\{ # examplesIf}
met_set <- yardstick::metric_set(yardstick::mae, yardstick::rmse, yardstick::rsq)
results$metrics <- lapply(
  results$result,
  \(x) met_set(x, truth = truth, estimate = estimate)
)
tidyr::unnest(dplyr::select(results, -result), metrics)

results_custom$metrics <- lapply(
  results_custom$result,
  \(x) met_set(x, truth = truth, estimate = estimate)
)
tidyr::unnest(dplyr::select(results_custom, -result), metrics)
\dontshow{\}) # examplesIf}
}
