% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tune_imp.R
\name{tune_imp}
\alias{tune_imp}
\title{Tune Parameters for Imputation Methods}
\usage{
tune_imp(
  obj,
  parameters,
  .f = "knn_imp",
  rep = 1,
  num_na = 100,
  rowmax = 0.9,
  colmax = 0.9,
  max_iter = 1000,
  .progress = FALSE,
  cores = 1
)
}
\arguments{
\item{obj}{A numeric matrix with \strong{samples in rows} and \strong{features in columns}.}

\item{parameters}{Data frame of parameter combinations to tune where each column is
a parameter accepted by \code{.f}. Duplicates are removed. Supports list columns.}

\item{.f}{Imputation function: "knn_imp" (default), "slide_imp", "pca_imp", or custom function.}

\item{rep}{Positive integer for random NA injections per combination (default 1), or
list of integer vectors specifying linear NA positions of a matrix (all unique, same length).}

\item{num_na}{Number of NAs to inject if \code{rep} is integer (default 100). Ignored if \code{rep} is list.}

\item{rowmax}{Max proportion of NAs per row (0-1, default 1).}

\item{colmax}{Max proportion of NAs per column (0-1, default 1).}

\item{max_iter}{Max iterations to find valid NA positions (default 1000).}

\item{.progress}{Show progress bar (default FALSE).}

\item{cores}{Number of cores for parallelization (default 1).}
}
\value{
Tibble with parameter columns, \code{param_set} (ID), \code{rep} (repetition), and \code{result} (nested tibble of \code{truth} and \code{estimate}).
}
\description{
Tunes hyperparameters for imputation methods like \code{\link[=slide_imp]{slide_imp()}}, \code{\link[=knn_imp]{knn_imp()}}, \code{\link[=pca_imp]{pca_imp()}},
or custom functions by injecting missing values into the dataset and evaluating
performance across parameter combinations.
}
\details{
Supports tuning built-in methods ('slide_imp', 'knn_imp', 'pca_imp') or custom functions via \code{.f}.

For custom \code{.f}, \code{parameters} columns must match \code{.f}'s arguments (excluding \code{obj}). The
function must take \code{obj} as an argument and return a numeric matrix of the same dimensions.
}
\examples{
data(khanmiss1)

parameters <- data.frame(
  n_feat = c(100, 100, 100),
  k = c(5, 10, 10),
  n_overlap = c(10, 10, 10),
  knn_method = "euclidean",
  post_imp = FALSE
)

set.seed(1234)
obj <- t(khanmiss1)[1:20, sample.int(nrow(khanmiss1), size = 200)]

# Random NA injection
results <- tune_imp(obj, parameters, .f = "slide_imp", rep = 1, num_na = 20)

# Specific NA positions
obj_complete <- obj
obj_complete[is.na(obj_complete)] <- 0
na_positions <- list(
  sample(1:length(obj_complete), 20, replace = FALSE),
  sample(1:length(obj_complete), 20, replace = FALSE),
  sample(1:length(obj_complete), 20, replace = FALSE)
)
results_fixed <- tune_imp(obj_complete, data.frame(k = 10), .f = "knn_imp", rep = na_positions)

# Custom imputation
custom_imp <- function(obj, mean = 0, sd = 1) {
  na_pos <- is.na(obj)
  obj[na_pos] <- rnorm(sum(na_pos), mean = mean, sd = sd)
  obj
}
parameters_custom <- data.frame(mean = c(0, 0, 1), sd = c(1, 2, 1))
results_custom <- tune_imp(obj, parameters_custom, .f = custom_imp, rep = 1, num_na = 20)

# Analyze the results with yardstick
\dontshow{if (requireNamespace("dplyr", quietly = TRUE) && requireNamespace("yardstick", quietly = TRUE) && requireNamespace("tidyr", quietly = TRUE)) withAutoprint(\{ # examplesIf}
met_set <- yardstick::metric_set(yardstick::mae, yardstick::rmse, yardstick::rsq)
results$metrics <- lapply(results$result, \(x) met_set(x, truth = truth, estimate = estimate))
tidyr::unnest(dplyr::select(results, -result), metrics)

results_custom$metrics <- lapply(results_custom$result, \(x) met_set(x, truth = truth, estimate = estimate))
tidyr::unnest(dplyr::select(results_custom, -result), metrics)
\dontshow{\}) # examplesIf}
}
