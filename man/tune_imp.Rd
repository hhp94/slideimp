% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tune_imp.R
\name{tune_imp}
\alias{tune_imp}
\title{Tune Parameters for \code{\link[=SlideKnn]{SlideKnn()}}/\code{\link[=knn_imp]{knn_imp()}}/Custom Imputation}
\usage{
tune_imp(
  obj,
  parameters,
  .f = "SlideKnn",
  rep = 1,
  num_na = 100,
  max_iter = 1000,
  .progress = FALSE,
  rowmax = 0.9,
  colmax = 0.9,
  cores = 1
)
}
\arguments{
\item{obj}{A numeric matrix with \strong{samples in rows} and \strong{features in columns}.
Note: keep \code{obj} small since this function doesn't support \code{bigmemory}.}

\item{parameters}{A data frame specifying the parameter combinations to tune. Duplicated rows are
removed. The required columns depend on \code{.f}; see \code{\link[=knn_imp]{knn_imp()}} or \code{\link[=SlideKnn]{SlideKnn()}} for details about
the parameters. Any \code{nboot} values in this data frame will be ignored.}

\item{.f}{The imputation function to tune. Can be the string "SlideKnn" (default), "knn_imp", or
a custom function. See details.}

\item{rep}{The number of repetitions for injecting missing values to evaluate each combination of
parameters. Default is 1.}

\item{num_na}{The number of missing values used to estimate prediction quality. Must be a positive integer.}

\item{max_iter}{Maximum number of iterations to attempt finding valid NA positions (default: 1000).}

\item{.progress}{Logical; if \code{TRUE}, show a progress bar. Default is \code{FALSE}.}

\item{rowmax}{Numeric between 0 and 1 specifying the maximum allowable proportion
of missing values in any row. If exceeded, the function stops with an error.}

\item{colmax}{Numeric between 0 and 1 specifying the threshold proportion of
missing values in a column above which the column is imputed using the mean
instead of k-NN if \code{post_imp} is true.}

\item{cores}{Integer specifying the number of cores to use for parallel computation
of distances. Default is 1.}
}
\value{
A tibble containing:
\itemize{
\item All parameter columns from the input \code{parameters} data frame
\item \code{param_set}: Integer identifier for each unique parameter combination
\item \code{rep}: The repetition number
\item \code{result}: A nested tibble with columns \code{truth} (original values) and \code{estimate} (imputed values)
}
}
\description{
This function tunes the parameters for the \code{\link[=SlideKnn]{SlideKnn()}} or \code{\link[=knn_imp]{knn_imp()}} imputation methods by injecting
missing values into the dataset multiple times and evaluating the imputation performance for different
parameter combinations. Can also tune custom imputation functions.
}
\details{
This function allows tuning of hyperparameters for matrix imputation methods, including the built-in
'SlideKnn' and 'knn_imp', or a custom function provided to \code{.f}.

For a custom function in \code{.f}, the \code{parameters} data.frame must have columns whose names match the
argument names of \code{.f} (excluding \code{obj}). The custom function must take \code{obj} as its first input
argument and output a numeric matrix of the same dimensions as \code{obj}.

For the built-in methods ('SlideKnn' or 'knn_imp'), certain parameters are required in \code{parameters}:
\itemize{
\item For 'SlideKnn': \code{n_feat}, \code{k}, and \code{n_overlap}
\item For 'knn_imp': \code{k}
}

Default values are set for optional parameters if not provided (e.g., \code{method = "euclidean"},
\code{post_imp = FALSE}).

\strong{Note:} The \code{nboot} parameter is always internally set to 1 for tuning purposes, regardless of
any value provided in \code{parameters}.
}
\examples{
data(khanmiss1)

parameters <- data.frame(
  n_feat = c(100, 100, 100),
  k = c(5, 10, 10),
  n_overlap = c(10, 10, 10),
  method = "euclidean",
  # Set post_imp to FALSE to estimate just the k-NN imputation quality
  post_imp = FALSE
)

set.seed(1234)
# Tune SlideKnn function on a subset of khanmiss1
obj <- t(khanmiss1)[1:30, sample.int(nrow(khanmiss1), size = 200)]
anyNA(obj)
results <- tune_imp(obj, parameters, .f = "SlideKnn", rep = 1)

# # Install {yardstick} or calculate any other metrics using the result
# library(yardstick)
# met_set <- metric_set(mae, rmse, rsq)
# results$metrics <- lapply(
#   results$result,
#   function(x) {
#     met_set(x, truth = truth, estimate = estimate)
#   }
# )
# # Unnest the metrics
# tidyr::unnest(dplyr::select(results, -result), cols = "metrics")

# Example with a custom imputation function where missing values are filled with random values
custom_imp <- function(obj, mean = 0, sd = 1) {
  na_pos <- is.na(obj)
  obj[na_pos] <- rnorm(sum(na_pos), mean = mean, sd = sd)
  return(obj)
}

parameters_custom <- data.frame(
  mean = c(0, 0, 1),
  sd = c(1, 2, 1)
)

set.seed(1234)
# Reuse the same obj
results_custom <- tune_imp(obj, parameters_custom, .f = custom_imp, rep = 1)

# # Similarly, compute metrics
# results_custom$metrics <- lapply(
#   results_custom$result,
#   function(x) {
#     met_set(x, truth = truth, estimate = estimate)
#   }
# )
# tidyr::unnest(dplyr::select(results_custom, -result), cols = "metrics")

}
\seealso{
\code{\link[=knn_imp]{knn_imp()}}, \code{\link[=SlideKnn]{SlideKnn()}}, \code{\link[=inject_na]{inject_na()}}
}
