% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slide_imp.R
\name{slide_imp}
\alias{slide_imp}
\title{Sliding Window k-NN Imputation}
\usage{
slide_imp(
  obj,
  n_feat,
  n_overlap = 10,
  imp_method = c("knn", "pca"),
  k = 10,
  colmax = 0.9,
  knn_method = c("euclidean", "manhattan"),
  cores = 1,
  post_imp = TRUE,
  dist_pow = 0,
  subset = NULL,
  ncp = 2,
  pca_method = c("regularized", "em"),
  coeff.ridge = 1,
  scale = TRUE,
  seed = NULL,
  nb.init = 1,
  maxiter = 1000,
  miniter = 5,
  .progress = FALSE,
  ...
)
}
\arguments{
\item{obj}{A numeric matrix with \strong{samples in rows} and \strong{features in columns}.
Features should be meaningfully ordered (e.g., by genomic position or time).}

\item{n_feat}{Integer. Number of features (columns) per sliding window.
Must be between 2 and \code{ncol(obj)}.}

\item{n_overlap}{Integer. Number of overlapping features between consecutive
windows. Must be between 0 and \code{n_feat - 1}. Default: 10.}

\item{k}{Integer. Number of nearest neighbors for imputation. Must be between
1 and \code{n_feat - 1}. Default: 10.}

\item{colmax}{Numeric. Threshold proportion of missing values per column (0-1).
Columns exceeding this threshold are imputed using column means when
\code{post_imp = TRUE}. Default: 0.9.}

\item{cores}{Integer. Number of CPU cores for parallel distance computation. Default: 1.}

\item{post_imp}{Logical. Whether to impute remaining missing values with
column means. Default: \code{TRUE}.}

\item{dist_pow}{Numeric. Positive value controlling distance penalty in weighted
imputation. Default: 0 (un-weighted).}

\item{subset}{Character vector of column names or integer vector of column
indices specifying which columns to impute. If \code{NULL} (default), all columns
are processed.}

\item{.progress}{Logical. Whether to display progress messages during imputation.
Default: \code{FALSE}.}

\item{rowmax}{Numeric. Maximum allowable proportion of missing values per row
(0-1). Function stops with error if exceeded. Default: 0.9.}

\item{method}{Character. Distance metric for k-NN: \code{"euclidean"} or \code{"manhattan"}.
Default: \code{"euclidean"}.}
}
\value{
A matrix with \code{dim(obj)} with missing values imputed.
}
\description{
Performs k-nearest neighbor imputation on large numeric matrices using a sliding
window approach column-wise. This method assumes that columns are meaningfully sorted.
}
\details{
The sliding window approach divides the input matrix into smaller, overlapping
segments and applies k-NN imputation to each window independently. This strategy
is particularly advantageous for large data where applying k-NN imputation
to the entire matrix would be computationally prohibitive or exceed memory limits.

Values in overlapping areas are averaged across windows to produce the final imputed result.
This approach assumes that features (columns) are ordered meaningfully (e.g.,
by genomic position, time series, etc.).

For the underlying k-NN implementation details, see \code{\link[=knn_imp]{knn_imp()}}.
}
\examples{
# Generate sample data with missing values with 20 samples and 100 columns
# where the column order is sorted (e.g., by genomic position or time)

set.seed(1234)
beta_matrix <- t(sim_mat(100, 20)$input)

# ========================================
# Basic Sliding k-NN Imputation
# ========================================

# Simple imputation with default parameters
imputed_basic <- slide_imp(
  beta_matrix,
  k = 5,
  n_feat = 50,
  n_overlap = 10
)
imputed_basic

}
