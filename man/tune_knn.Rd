% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tune_knn.R
\name{tune_knn}
\alias{tune_knn}
\title{Tune Parameters for \code{SlideKnn}/\code{knn_imp} Imputation}
\usage{
tune_knn(
  obj,
  parameters,
  rep = 1,
  num_na = 100,
  max_iter = 1000,
  rowmax = 0.9,
  colmax = 0.9,
  verbose = TRUE,
  cores = 1,
  .parallel = FALSE
)
}
\arguments{
\item{obj}{A numeric matrix with \strong{samples in rows} and \strong{features in columns}. See details.}

\item{parameters}{A data frame specifying the parameter combinations to tune. Must include columns
`n_feat`, `k`, `n_overlap`, `method` and `post_imp`. Duplicate rows are automatically removed.
See [knn_imp()] or [SlideKnn()] for details about the parameters.}

\item{rep}{The number of repetitions for injecting missing values and evaluating parameters. Default is 1.}

\item{num_na}{The number of missing values used to estimate prediction quality. Must be a positive integer.}

\item{max_iter}{Maximum number of iterations to attempt finding valid NA positions (default: 1000).}

\item{rowmax}{A numeric value between 0 and 1. This is the maximum
allowable proportion of missing values in any single row. If a row
exceeds this threshold, the function will stop with an error.}

\item{colmax}{A numeric value between 0 and 1. This is the threshold for the
proportion of missing values in a column. Columns exceeding this
threshold will be imputed using the column mean instead of k-NN.}

\item{verbose}{Print out progress? Default is TRUE.}

\item{cores}{Number of cores to parallelize calculations of distances over. Note: if \code{.parallel} is TRUE and cores = n, then each [mirai::daemons()] process will spawn n cores.}

\item{.parallel}{Logical indicating whether to use parallel processing for multiple windows. Default is FALSE.}
}
\value{
A tibble containing the tuning results. Each row corresponds to a specific repetition and
  parameter combination, with columns:
  \itemize{
    \item `rep`: The repetition number.
    \item `param_id`: The ID of the parameter combination.
    \item `n_feat`, `k`, `n_overlap`, `method`, `post_imp`: The parameter values used.
    \item `result`: A nested tibble with columns `truth` (original values) and `estimate`
      (imputed values) for the injected NAs.
  }
}
\description{
This function tunes the parameters for the [SlideKnn()]/[knn_imp()] imputation method by injecting missing values
into the dataset multiple times and evaluating the imputation performance for different parameter
combinations. Set \code{n_feat = ncol(obj)} and \code{n_overlap = 0} to tune [knn_imp()]
}
\examples{
\dontrun{
data(khanmiss1)

parameters <- dplyr::tibble(
  n_feat = c(100, 100, 100),
  k = c(5, 10, 10),
  n_overlap = c(10, 10, 10),
  method = "euclidean",
  post_imp = TRUE
)

set.seed(1234)

results <- tune_knn(
  t(khanmiss1),
  parameters,
  rep = 5
)

# Compute multiple metrics using yardstick
library(yardstick)
met_set <- metric_set(mae, rmse, rsq)
results$metrics <- lapply(
  results$result,
  function(x) {
    met_set(x, truth = truth, estimate = estimate)
  }
)

# Unnest the metrics
tidyr::unnest(dplyr::select(results, -result), cols = "metrics")

# View metrics for the first result
results$metrics[[1]]
}

}
\seealso{
[knn_imp()] or [SlideKnn()] for parameters details.
}
