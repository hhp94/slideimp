% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{impute_knn_mlpack}
\alias{impute_knn_mlpack}
\title{Impute missing values in a matrix using treed k-nearest neighbors (k-NN)}
\usage{
impute_knn_mlpack(
  obj,
  miss,
  k,
  n_col_miss,
  method,
  tree,
  weighted,
  dist_pow,
  n_imp = 1L,
  seed = 42L,
  cores = 1L
)
}
\arguments{
\item{obj}{Numeric matrix with missing values pre-filled with colMeans.}

\item{miss}{Logical matrix (0/1) indicating missing values (1 = missing).}

\item{k}{Number of nearest neighbors to use for imputation.}

\item{n_col_miss}{Integer vector specifying the count of missing values per column.}

\item{method}{Integer specifying the distance metric: 0 = Euclidean, 1 = Manhattan.}

\item{tree}{Which type of tree? "kd" or "ball".}

\item{weighted}{Boolean controls for the imputed value to be a simple mean or weighted mean by inverse distance.
Note: Forced to FALSE when \code{n_imp > 1}.}

\item{dist_pow}{A positive double that controls the penalty for larger distances in
the weighted mean imputation. Must be greater than zero: values between 0 and 1 apply a softer penalty,
1 is linear (default), and values greater than 1 apply a harsher penalty.}

\item{n_imp}{Integer specifying the number of bootstrap replicates for imputation (default = 1). If > 1, enables bootstrapping.}

\item{seed}{Integer seed for random number generation during bootstrapping (default = 42). Only used when \code{n_imp > 1}.}

\item{cores}{Number of CPU cores to use for parallel processing (default = 1).}
}
\value{
A matrix where the first column is the 1-based row index, the second column is the 1-based column index,
and the subsequent \code{n_imp} columns contain the imputed values (one column per bootstrap replicate if \code{n_imp > 1}).
}
\description{
k-NN using KDTree or BallTree with optional bootstrap support for uncertainty estimation.
}
\details{
When \code{n_imp > 1}, bootstrapping is enabled: for each missing value, \code{n_imp} imputed values are generated
by resampling the k nearest neighbors with replacement and using simple averages (weighted is forced to FALSE).
This provides variability estimates for imputation uncertainty.
}
