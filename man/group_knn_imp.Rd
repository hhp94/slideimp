% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/group_knn_imp.R
\name{group_knn_imp}
\alias{group_knn_imp}
\title{Grouped K-NN Imputation}
\usage{
group_knn_imp(
  obj,
  group,
  k,
  colmax = 0.9,
  rowmax = 0.9,
  method = c("euclidean", "manhattan"),
  cores = 1,
  post_imp = TRUE,
  weighted = FALSE,
  dist_pow = 1,
  tree = NULL,
  n_imp = 1,
  n_pmm = -1,
  seed = 42,
  output = NULL,
  overwrite = FALSE,
  .progress = TRUE
)
}
\arguments{
\item{obj}{A numeric matrix with \strong{samples in rows} and \strong{features in columns}.
Must have at least 1 row and 2 columns.}

\item{group}{A data.frame with columns:
\describe{
\item{features}{A list column containing character vectors of feature column names to impute}
\item{aux}{A list column containing character vectors of auxiliary column names used for imputation but not imputed themselves}
\item{parameters}{(Optional) A list column containing group-specific parameters that override global settings. Allowed parameters: \code{k}, \code{weighted}, \code{method}, \code{tree}, \code{dist_pow}}
}}

\item{k}{Integer. Number of nearest neighbors for imputation. Must be between
1 and \code{n_feat - 1}. Default: 10.}

\item{colmax}{Numeric. Threshold proportion of missing values per column (0-1).
Columns exceeding this threshold are imputed using column means instead of
k-NN when \code{post_imp = TRUE}. Default: 0.9.}

\item{rowmax}{Numeric. Maximum allowable proportion of missing values per row
(0-1). Function stops with error if exceeded. Default: 0.9.}

\item{method}{Character. Distance metric for k-NN: \code{"euclidean"} or \code{"manhattan"}.
Default: \code{"euclidean"}.}

\item{cores}{Integer. Number of CPU cores for parallel distance computation.
Requires \code{\link[mirai:daemons]{mirai::daemons()}} setup for \code{cores} > 1. Default: 1.}

\item{post_imp}{Logical. Whether to impute remaining missing values with
column means after k-NN imputation. Default: \code{TRUE}.}

\item{weighted}{Logical. Whether to use distance-weighted mean for imputation.
If \code{FALSE}, uses simple mean of k nearest neighbors. Default: \code{FALSE}.}

\item{dist_pow}{Numeric. Positive value controlling distance penalty in weighted
imputation. Values < 1 apply softer penalty, 1 is linear, > 1 is harsher.
Only used when \code{weighted = TRUE}. Default: 1.}

\item{tree}{Character. k-NN search method: \code{NULL} (brute-force), \code{"kd"} (KDTree),
or \code{"ball"} (BallTree). Tree methods may introduce bias with high missingness.
Default: \code{NULL}.}

\item{n_imp}{Integer. Number of multiple imputations to perform. Automatically
set to 1 if \code{n_pmm = -1}. Default: 1.}

\item{n_pmm}{Integer. Multiple imputation method control:
\itemize{
\item \code{-1}: Deterministic single imputation (default)
\item \verb{> 0}: Predictive Mean Matching using \code{n_pmm} closest donors
(recommended for MI. \code{8} is a good starting point.).
\item \code{0}: Bootstrap resampling from k-nearest neighbors
}}

\item{seed}{Integer. Random seed for reproducible results in stochastic imputation
methods. Default: 42.}

\item{output}{Character. File path stem for saving file-backed big.matrix results
(format: \code{"path/stem"}). If \code{NULL}, results are stored in memory. Recommended
for large data and multiple imputations.}

\item{overwrite}{Logical. Whether to overwrite existing files at \code{output} path.
Default: \code{FALSE}. See Notes for Windows.}

\item{.progress}{Shows progress}
}
\value{
A list of length \code{n_imp} containing numeric matrices or \code{\link[bigmemory:big.matrix]{bigmemory::big.matrix()}}
objects (if \code{output} is specified) with the same dimensions as \code{obj}. Missing values
are imputed using k-NN for columns with missingness below \code{colmax}, and mean
imputation for remaining missing values if \code{post_imp = TRUE}. Only the features
specified in the groups are imputed; other columns remain unchanged.

The list has class \code{"KnnImpList"} with attributes:
\itemize{
\item \code{rownames}: Original row names from input matrix
\item \code{colnames}: Original column names from input matrix
\item \code{subset}: Column indices that were processed for imputation
\item \code{ncol}: Number of columns in original matrix
}

Each list element represents an independent imputation. The only element of the
list when \code{n_pmm == -1} is a single imputed matrix.
}
\description{
K-NN imputation by groups, such as chromosomes, flanking columns, or clusters identified by column clustering techniques.
}
\details{
This function performs K-NN imputation on groups of features independently, which will significantly
reduce imputation time for large datasets. Typical strategies for grouping may include:
\itemize{
\item Breaking down search space by chromosome for epigenetics data
\item Grouping features with their flanking values/neighbors (e.g., 1000 bp down/up stream of a CpG)
\item Using clusters identified by column clustering techniques
}

Only features in each group (each row of the data.frame) will be imputed, using the search space
defined as the union of the features and aux columns of that group. Columns that are in aux or in the object
but not in any features will be left unchanged.
}
\note{
\strong{File-backed Storage}: For file-backed results using \code{output}, set
\code{options(bigmemory.allow.dimnames = TRUE)} before calling this function to preserve
dimnames, otherwise they can be manually restored from the original matrix with
\code{\link[=restore_dimnames]{restore_dimnames()}}.

\strong{File locks On Windows}: file-backed big.matrix objects hold file locks.
If you need to overwrite existing files, ensure previous results that points
to the same files are removed with \code{\link[=rm]{rm()}} and \code{\link[=gc]{gc()}} first.

\strong{Memory Considerations}: When \code{n_imp > 1} for large data, use \code{subset} to
specify only required columns and provide \code{output} for file-backed storage to
avoid memory constraints.
}
\examples{
# Generate example data with missing values. This simulates a 20x50 matrix with missing values
# and groups by chromosome. Here we are simulating 2 chromosomes.
set.seed(1234)
to_test <- sim_mat(
  m = 20,
  n = 50,
  perc_NA = 0.3,
  perc_col_NA = 1,
  nchr = 2
)

# `group_1` will be all the CpGs on Chr1. Same for `group_2`
group_1 <- subset(to_test$group_feature, group == "chr1")$feature_id
group_2 <- subset(to_test$group_feature, group == "chr2")$feature_id

# Impute only first 3 values of group 1, the rest are aux. Group 2 does 4 features.
# Also optionally vary the parameters by group
group_df <- tibble::tibble(
  features = list(group_1[1:3], group_2[1:4]),
  aux = list(group_1, group_2),
  parameters = list(list(k = 3, weighted = TRUE), list(k = 4, method = "manhattan"))
)
group_df

# Run grouped imputation. t() to put features on the columns
obj <- t(to_test$input)
grouped_results <- group_knn_imp(obj, group = group_df, k = 5)
grouped_results
}
\seealso{
\code{\link[=SlideKnn]{SlideKnn()}}, \code{\link[=mean_impute_col]{mean_impute_col()}}, \code{\link[bigmemory:big.matrix]{bigmemory::big.matrix()}}, \code{\link[=restore_dimnames]{restore_dimnames()}}, \code{\link[=knn_imp]{knn_imp()}}
}
