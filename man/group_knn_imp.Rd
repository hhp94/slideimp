% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/group_knn_imp.R
\name{group_knn_imp}
\alias{group_knn_imp}
\title{Grouped K-NN Imputation}
\usage{
group_knn_imp(
  obj,
  group,
  k,
  colmax = 0.9,
  rowmax = 0.9,
  method = c("euclidean", "manhattan"),
  cores = 1,
  post_imp = TRUE,
  weighted = FALSE,
  dist_pow = 1,
  tree = NULL,
  n_imp = 1,
  n_pmm = -1,
  seed = 42,
  output = NULL,
  overwrite = FALSE,
  .progress = TRUE
)
}
\arguments{
\item{obj}{A numeric matrix with \strong{samples in rows} and \strong{features in columns}.}

\item{group}{A data.frame with columns:
\describe{
\item{features}{A list column containing character vectors of feature column names to impute}
\item{aux}{A list column containing character vectors of auxiliary column names used for imputation but not imputed themselves}
\item{parameters}{(Optional) A list column containing group-specific parameters that override global settings. Allowed parameters: \code{k}, \code{weighted}, \code{method}, \code{tree}, \code{dist_pow}}
}}

\item{k}{Number of nearest neighbors for imputation. 10 is a good starting point.}

\item{colmax}{Numeric. Threshold proportion of missing values per column (0-1).
Columns exceeding this threshold are imputed using column means when
\code{post_imp = TRUE}. Default: 0.9.}

\item{method}{Character. Distance metric for k-NN: \code{"euclidean"} or \code{"manhattan"}.
Default: \code{"euclidean"}.}

\item{cores}{Integer. Number of CPU cores for parallel distance computation. Default: 1.}

\item{post_imp}{Logical. Whether to impute remaining missing values with
column means. Default: \code{TRUE}.}

\item{dist_pow}{Numeric. Positive value controlling distance penalty in weighted
imputation. Default: 0 (un-weighted).}

\item{.progress}{Shows progress}
}
\value{
A matrix with \code{dim(obj)} with missing values imputed.
}
\description{
K-NN imputation by groups, such as chromosomes, flanking columns, or clusters identified by column clustering techniques.
}
\details{
This function performs K-NN imputation on groups of features independently, which will significantly
reduce imputation time for large datasets. Typical strategies for grouping may include:
\itemize{
\item Breaking down search space by chromosomes
\item Grouping features with their flanking values/neighbors (e.g., 1000 bp down/up stream of a CpG)
\item Using clusters identified by column clustering techniques
}

Only features in each group (each row of the data.frame) will be imputed, using the search space
defined as the union of the features and aux columns of that group. Columns that are in aux or in the object
but not in any features will be left unchanged.
}
\examples{
# Generate example data with missing values. This simulates a 20x50 matrix with missing values
# and groups by chromosome. Here we are simulating 2 chromosomes.
set.seed(1234)
to_test <- sim_mat(
  m = 20,
  n = 50,
  perc_NA = 0.3,
  perc_col_NA = 1,
  nchr = 2
)

# `group_1` will be all the CpGs on Chr1. Same for `group_2`
group_1 <- subset(to_test$group_feature, group == "chr1")$feature_id
group_2 <- subset(to_test$group_feature, group == "chr2")$feature_id

# Impute only first 3 values of group 1, the rest are aux. Group 2 does 4 features.
# Also optionally vary the parameters by group
group_df <- tibble::tibble(
  features = list(group_1[1:3], group_2[1:4]),
  aux = list(group_1, group_2),
  parameters = list(list(k = 3, weighted = TRUE), list(k = 4, method = "manhattan"))
)
group_df

# Run grouped imputation. t() to put features on the columns
obj <- t(to_test$input)
grouped_results <- group_knn_imp(obj, group = group_df, k = 5)
grouped_results
}
