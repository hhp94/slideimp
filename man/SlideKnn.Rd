% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SlideKnn.R
\name{SlideKnn}
\alias{SlideKnn}
\title{Sliding k-NN Imputation}
\usage{
SlideKnn(
  obj,
  n_feat,
  subset = NULL,
  n_overlap = 10,
  k = 10,
  rowmax = 0.9,
  colmax = 0.9,
  cores = 1,
  method = c("euclidean", "manhattan"),
  tree = NULL,
  post_imp = TRUE,
  weighted = FALSE,
  dist_pow = 1,
  n_imp = 1,
  n_pmm = -1,
  seed = 42,
  .progress = FALSE,
  output = NULL,
  overwrite = FALSE,
  strip_dimnames = FALSE
)
}
\arguments{
\item{obj}{A numeric matrix with \strong{samples in rows} and \strong{features in columns}.
Ensure that the features in the columns are sorted (e.g., by genomic position).
Can also be a path to the description file of, or a \code{\link[bigmemory:big.matrix]{bigmemory::big.matrix()}}.}

\item{n_feat}{Integer specifying the number of features (columns) in each window.
Must be between 2 and the number of columns in \code{obj}.}

\item{subset}{Character vector of column names or integer vector of column indices
specifying the subset of columns on which to perform imputation. If \code{NULL} (default),
all columns are included.}

\item{n_overlap}{Integer specifying the number of features to overlap between
consecutive windows. Default is 10. Must be between 0 and \code{n_feat - 1}.}

\item{k}{Integer specifying the number of nearest neighbors to use for imputation.
Must be between 1 and (\code{n_feat} - 1).}

\item{rowmax}{Numeric between 0 and 1 specifying the maximum allowable proportion
of missing values in any row. If exceeded, the function stops with an error.}

\item{colmax}{Numeric between 0 and 1 specifying the threshold proportion of
missing values in a column above which the column is imputed using the mean
instead of k-NN if \code{post_imp} is \code{TRUE}.}

\item{cores}{Integer specifying the number of cores to use for parallel computation
of distances. Default is 1.}

\item{method}{Character string specifying the distance metric for k-NN. One of
\code{"euclidean"} or \code{"manhattan"}. Defaults to \code{"euclidean"}.}

\item{tree}{Character string specifying the k-NN method. \code{NULL} (default) uses
brute-force search. \code{"kd"} uses KDTree and \code{"ball"} uses BallTree as implemented by
the mlpack package, where missing values are first filled with column means
(biased at high percentage of missing values and less efficient at lower dimensions).}

\item{post_imp}{Logical; if \code{TRUE} (default), any missing values remaining after
k-NN imputation will be imputed with \code{\link[=mean_impute_col]{mean_impute_col()}}.}

\item{weighted}{Logical; controls whether the imputed value should be a simple
mean or weighted mean by inverse distance. Default is \code{FALSE}.}

\item{dist_pow}{A positive double that controls the penalty for larger distances
in the weighted mean imputation. Must be greater than zero: values between 0
and 1 apply a softer penalty, 1 is linear (default), and values greater than
1 apply a harsher penalty.}

\item{n_imp}{Integer specifying the number of imputations to perform. Forced
to 1 if \code{n_pmm} = -1.}

\item{n_pmm}{Integer controlling the multiple imputation method.
If \code{n_pmm} = -1 (default): Deterministic single imputation.
If \code{n_pmm} > 0: (recommended for MI) PMM multiple imputation using \code{n_pmm} closest
donors (will not exceed available non-missing values row-wise).
If \code{n_pmm} = 0: Bootstrap multiple imputation via resampling from k-Nearest Neighbors.}

\item{seed}{Integer; random seed for reproducible bootstrap sampling. Default is 42.}

\item{.progress}{Logical; if \code{TRUE}, show a progress bar. Default is \code{FALSE}.}

\item{output}{Character; path to save the output big.matrix. Format should be
\code{path/stem} (e.g. "./my_results"). If provided, the back end will switch
to \code{\link[bigmemory:big.matrix]{bigmemory::filebacked.big.matrix()}} instead of in-memory matrix.}

\item{overwrite}{Logical; if \code{TRUE}, overwrite existing files at \code{output}. Default to \code{FALSE}.}

\item{strip_dimnames}{Logical; if \code{FALSE} (default), dimnames will not be removed,
which will increase memory usage. Should be set to \code{TRUE} to save memory from
overhead, especially when \code{cores} > 1. See details.}
}
\value{
A list of numeric matrices/big.matrices of the same dimensions as \code{obj}
with missing values imputed. Length of list equals \code{n_imp}. If \code{obj} is file-backed,
returns a list of big.matrix objects; otherwise returns regular matrices.
}
\description{
Performs sliding window k-NN imputation on a numeric matrix to handle missing values.
The matrix is divided into overlapping windows, and imputation is applied to each window.
Overlapping regions are averaged to produce the final imputed matrix.
}
\details{
The sliding window approach is particularly useful for large datasets where applying
k-NN imputation to the entire matrix would be computationally prohibitive. By breaking
the data into smaller, overlapping windows, the algorithm maintains local structures
while keeping memory usage manageable.

See \code{\link[=knn_imp]{knn_imp()}} for details about the underlying k-NN implementation.
}
\note{
Setting \code{n_imp} > 1 (i.e., multiple imputation) is intended to be used with \code{subset}.
and big.matrix.

If your \code{obj} is a \code{\link[bigmemory:big.matrix]{bigmemory::big.matrix()}} or description file, you must set
\code{strip_dimnames} to \code{TRUE} for the output big.matrix to have the same dimnames as
the \code{obj}. Alternatively, you can re-add the dimnames to the output using the
dimnames of the original object after setting \code{options(bigmemory.allow.dimnames = TRUE)}.
}
\examples{
# Generate sample data with missing values with 20 samples and 100 columns
# where the column order is sorted (e.g., by genomic position or time)

set.seed(1234)
beta_matrix <- t(sim_mat(100, 20)$input)

# ========================================
# Basic Sliding k-NN Imputation
# ========================================

# Simple imputation with default parameters
imputed_basic <- SlideKnn(
  beta_matrix,
  k = 5,
  n_feat = 50,
  n_overlap = 10
)

# Access the result (returns a list, even for single imputation)
imputed_basic[[1]][1:5, 1:5]

# ========================================
# Big Matrix Usage (Memory Efficient)
# ========================================

# Convert to big.matrix for better memory management
big_data <- bigmemory::as.big.matrix(beta_matrix, type = "double")

# output is NULL, the backend is still in-memory
imputed_big_in_memory <- SlideKnn(
  big_data,
  k = 5,
  n_feat = 50,
  output = NULL
)

# output is now set to a location to save. The backend is now filebacked matrix
# to handle massive data
imputed_big <- SlideKnn(
  big_data,
  k = 5,
  n_feat = 50,
  output = withr::local_tempfile()
  # strip_dimnames = TRUE  # Recommended to set to TRUE for efficiency
)

# Because strip_dimnames is `FALSE` and the default of the bigmatrix package
# is to not allow dimnames, the output lost the dimnames
imputed_big[[1]][, ][1:5, 1:5]

# But this can be reassigned after setting the options to be TRUE like so
if (interactive()) {
  options(bigmemory.allow.dimnames = TRUE)
  rownames(imputed_big[[1]]) <- rownames(big_data)
  colnames(imputed_big[[1]]) <- colnames(big_data)
  imputed_big[[1]][, ][1:5, 1:5]
}

# ========================================
# Multiple Imputation
# ========================================

# Predictive Mean Matching (PMM) - recommended
imputed_pmm <- SlideKnn(
  beta_matrix,
  k = 8,
  n_feat = 60,
  n_imp = 3, # 3 imputations
  n_pmm = 5, # 5 donors for PMM
  output = withr::local_tempfile(),
  .progress = TRUE
)

# ========================================
# Parallel Processing
# ========================================

\dontshow{if (interactive()) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}

# Set up parallel processing
library(mirai)
daemons(4) # Use 4 cores

# Enable for multi-core efficiency
options(bigmemory.allow.dimnames = TRUE)

# Parallel imputation
imputed_parallel <- SlideKnn(
  beta_matrix,
  k = 5,
  n_feat = 50,
  cores = 4,
  strip_dimnames = TRUE # Important for parallel efficiency
)

# Clean up
daemons(0)
\dontshow{\}) # examplesIf}
}
\seealso{
\code{\link[=knn_imp]{knn_imp()}}, \code{\link[=mean_impute_col]{mean_impute_col()}}, \code{\link[bigmemory:big.matrix]{bigmemory::big.matrix()}}
}
