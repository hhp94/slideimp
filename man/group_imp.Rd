% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/group_imp.R
\name{group_imp}
\alias{group_imp}
\title{Grouped K-NN Imputation}
\usage{
group_imp(
  obj,
  group,
  k = NULL,
  colmax = 0.9,
  knn_method = c("euclidean", "manhattan"),
  cores = 1,
  post_imp = TRUE,
  dist_pow = 0,
  tree = NULL,
  ncp = NULL,
  scale = TRUE,
  pca_method = c("Regularized", "EM"),
  coeff.ridge = 1,
  row.w = NULL,
  ind.sup = NULL,
  threshold = 1e-06,
  seed = NULL,
  nb.init = 1,
  maxiter = 1000,
  miniter = 5,
  .progress = TRUE
)
}
\arguments{
\item{obj}{A numeric matrix with \strong{samples in rows} and \strong{features in columns}.}

\item{group}{A data.frame with columns:
\describe{
\item{features}{A list column containing character vectors of feature column names to impute}
\item{aux}{A list column containing character vectors of auxiliary column names used for imputation but not imputed themselves}
\item{parameters}{(Optional) A list column containing group-specific parameters that override global settings. Allowed parameters: \code{k}, \code{weighted}, \code{method}, \code{tree}, \code{dist_pow}}
}}

\item{k}{Number of nearest neighbors for imputation. 10 is a good starting point.}

\item{colmax}{A number from 0 to 1. Threshold of missing data above which k-NN imputation is skipped.}

\item{cores}{Number of cores to parallelize over.}

\item{post_imp}{Logical flag indicating whether to impute remaining missing values (those that failed k-NN imputation) using column means.}

\item{dist_pow}{A numeric value controlling the degree of penalization of far-away nearest neighbors in the calculation of imputed values.
If \code{dist_pow = 0} (default), then the imputed value is just the mean of nearest neighbors regardless of distance.}

\item{tree}{Either \code{NULL} (default, brute-force k-NN), "kd", or "ball". Method to find nearest neighbors using the mlpack ball-tree or kd-tree.}

\item{.progress}{Shows progress}
}
\value{
A numeric matrix of the same dimensions as \code{obj} with missing values imputed.
}
\description{
K-NN imputation by groups, such as chromosomes, flanking columns, or clusters identified by column clustering techniques.
}
\details{
This function performs K-NN imputation on groups of features independently, which will significantly
reduce imputation time for large datasets. Typical strategies for grouping may include:
\itemize{
\item Breaking down search space by chromosomes
\item Grouping features with their flanking values/neighbors (e.g., 1000 bp down/up stream of a CpG)
\item Using clusters identified by column clustering techniques
}

Only features in each group (each row of the data.frame) will be imputed, using the search space
defined as the union of the features and aux columns of that group. Columns that are in aux or in the object
but not in any features will be left unchanged.
}
\examples{
# Generate example data with missing values. This simulates a 20x50 matrix with missing values
# and groups by chromosome. Here we are simulating 2 chromosomes.
set.seed(1234)
to_test <- sim_mat(
  m = 20,
  n = 50,
  perc_NA = 0.3,
  perc_col_NA = 1,
  nchr = 2
)

# `group_1` will be all the CpGs on Chr1. Same for `group_2`
group_1 <- subset(to_test$group_feature, group == "chr1")$feature_id
group_2 <- subset(to_test$group_feature, group == "chr2")$feature_id

# Impute only first 3 values of group 1, the rest are aux. Group 2 does 4 features.
# Also optionally vary the parameters by group
group_df <- tibble::tibble(
  features = list(group_1[1:3], group_2[1:4]),
  aux = list(group_1, group_2),
  parameters = list(list(k = 3, weighted = TRUE), list(k = 4, method = "manhattan"))
)
group_df

# Run grouped imputation. t() to put features on the columns
obj <- t(to_test$input)
grouped_results <- group_imp(obj, group = group_df, k = 5)
grouped_results
}
