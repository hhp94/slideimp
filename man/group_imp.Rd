% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/group_imp.R
\name{group_imp}
\alias{group_imp}
\title{Grouped K-NN or PCA Imputation}
\usage{
group_imp(
  obj,
  group,
  k = NULL,
  colmax = NULL,
  knn_method = NULL,
  post_imp = NULL,
  dist_pow = NULL,
  tree = NULL,
  cores = 1,
  ncp = NULL,
  scale = NULL,
  pca_method = NULL,
  coeff.ridge = NULL,
  threshold = NULL,
  seed = NULL,
  nb.init = NULL,
  maxiter = NULL,
  miniter = NULL,
  .progress = TRUE
)
}
\arguments{
\item{obj}{A numeric matrix with \strong{samples in rows} and \strong{features in columns}.}

\item{group}{Preferably created by \code{\link[=group_features]{group_features()}}. A data.frame with columns:
\describe{
\item{features}{A list column containing character vectors of feature column names to impute}
\item{aux}{(Optional) A list column containing character vectors of auxiliary
column names used for imputation but not imputed themselves}
\item{parameters}{(Optional) A list column containing group-specific parameters}
}}

\item{k}{Number of nearest neighbors for imputation. 10 is a good starting point.}

\item{colmax}{A number from 0 to 1. Threshold of missing data above which K-NN imputation is skipped.}

\item{knn_method}{Either "euclidean" (default) or "manhattan". Distance metric for nearest neighbor calculation.}

\item{post_imp}{Whether to impute remaining missing values (those that failed K-NN imputation)
using column means (default = \code{TRUE}).}

\item{dist_pow}{The amount of penalization for further away nearest neighbors in the weighted average.
\code{dist_pow = 0} (default) is the simple average of the nearest neighbors.}

\item{tree}{Either \code{NULL} (default, brute-force K-NN), "ball", or "kd" to find nearest neighbors using the \code{{mlpack}} ball-tree or kd-tree algorithms.}

\item{cores}{Controls the number of cores to parallelize over for K-NN imputation only.
To setup parallelization for PCA imputation, use \code{mirai::daemons()}.}

\item{ncp}{integer corresponding to the number of components used to to predict the missing entries}

\item{scale}{boolean. By default TRUE leading to a same weight for each variable}

\item{pca_method}{"regularized" by default or "EM".}

\item{coeff.ridge}{1 by default to perform the regularized pca_imp (imputePCA) algorithm; useful only if method="Regularized". Other regularization terms can be implemented by setting the value to less than 1 in order to regularized less (to get closer to the results of the EM method) or more than 1 to regularized more (to get closer to the results of the mean imputation)}

\item{threshold}{the threshold for assessing convergence}

\item{seed}{integer, by default seed = NULL implies that missing values are initially imputed by the mean of each variable. Other values leads to a random initialization}

\item{nb.init}{integer corresponding to the number of random initializations; the first initialization is the initialization with the mean imputation}

\item{maxiter}{integer, maximum number of iteration for the algorithm}

\item{miniter}{integer, minimum number of iteration for the algorithm}

\item{.progress}{Show imputation progress (default = FALSE)}
}
\value{
A numeric matrix of the same dimensions as \code{obj} with missing values imputed.
}
\description{
K-NN or PCA imputation by groups, such as chromosomes, flanking columns, or clusters
identified by column clustering techniques.
}
\details{
This function performs K-NN or PCA imputation on groups of features independently,
which significantly reduce imputation time for large datasets.

Specify \code{k} and related arguments to use K-NN, \code{ncp} and related arguments for PCA imputation.
If \code{k} and \code{ncp} are both \code{NULL}, then the group-wise parameters column i.e., \code{group$parameters}
must be specified and must contains either \code{k} or \code{ncp} for all groups of group-wise parameters.

Typical strategies for grouping may include:
\itemize{
\item Breaking down search space by chromosomes
\item Grouping features with their flanking values/neighbors (e.g., 1000 bp down/up stream of a CpG)
\item Using clusters identified by column clustering techniques
}

Only features in each group (each row of the data.frame) will be imputed, using
the search space defined as the union of the features and optional aux columns
of that group. Columns that are in aux or in the object but not in any features
will be left unchanged.
}
\examples{
# Generate example data with missing values
set.seed(1234)
to_test <- sim_mat(
  m = 20,
  n = 50,
  perc_NA = 0.3,
  perc_col_NA = 1,
  nchr = 2
)

# `group_1` will be all the CpGs on Chr1. Same for `group_2`
group_1 <- subset(to_test$group_feature, group == "chr1")$feature_id
group_2 <- subset(to_test$group_feature, group == "chr2")$feature_id

# Impute only first 3 values of group 1, the rest are aux. Group 2 does 4 features.
# Also optionally vary the parameters by group
knn_df <- tibble::tibble(
  features = list(group_1[1:3], group_2[1:4]),
  aux = list(group_1, group_2),
  parameters = list(
    list(k = 3, dist_pow = 1),
    list(k = 4, method = "manhattan")
  )
)
knn_df

# Run grouped imputation. t() to put features on the columns. `k` for K-NN has
# been specified in `knn_df`.
obj <- t(to_test$input)
knn_grouped <- group_imp(obj, group = knn_df)
knn_grouped

# Specify `ncp` for PCA in the `group_imp` function since no group-wise parameters are
# specified. Also run in parallel with `mirai::daemons(2)`

mirai::daemons(2) # Setup 2 cores for parallelization
pca_df <- tibble::tibble(
  features = list(group_1[1:3], group_2[1:4])
)
pca_grouped <- group_imp(obj, group = pca_df, ncp = 2)
mirai::daemons(0)

pca_grouped
}
\seealso{
\code{\link[=group_features]{group_features()}}
}
