% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SlideKnn.R
\name{knn_imp}
\alias{knn_imp}
\title{K-Nearest Neighbor Imputation for Missing Values}
\usage{
knn_imp(
  obj,
  k,
  colmax = 0.9,
  rowmax = 0.9,
  method = c("euclidean", "manhattan"),
  cores = 1,
  post_imp = TRUE,
  subset = NULL,
  weighted = FALSE,
  dist_pow = 1,
  tree = NULL,
  n_imp = 1,
  n_pmm = -1,
  seed = 42,
  output = NULL,
  overwrite = FALSE,
  ...
)
}
\arguments{
\item{obj}{A numeric matrix with \strong{samples in rows} and \strong{features in columns}.}

\item{k}{Number of nearest neighbors for imputation. 10 is a good starting point.}

\item{colmax}{Numeric. Threshold proportion of missing values per column (0-1).
Columns exceeding this threshold are imputed using column means instead of
k-NN when \code{post_imp = TRUE}. Default: 0.9.}

\item{rowmax}{Numeric. Maximum allowable proportion of missing values per row
(0-1). Function stops with error if exceeded. Default: 0.9.}

\item{method}{Character. Distance metric for k-NN: \code{"euclidean"} or \code{"manhattan"}.
Default: \code{"euclidean"}.}

\item{cores}{Integer. Number of CPU cores for parallel distance computation. Default: 1.}

\item{post_imp}{Logical. Whether to impute remaining missing values with
column means after k-NN imputation. Default: \code{TRUE}.}

\item{subset}{Character vector of column names or integer vector of column
indices specifying which columns to impute.}

\item{weighted}{Logical. Whether to use distance-weighted mean for imputation.
If \code{FALSE}, uses simple mean of k nearest neighbors. Default: \code{FALSE}.}

\item{dist_pow}{Numeric. Positive value controlling distance penalty in weighted
imputation. Values < 1 apply softer penalty, 1 is linear, > 1 is harsher.
Only used when \code{weighted = TRUE}. Default: 1.}

\item{tree}{Character. k-NN search method: \code{NULL} (brute-force), \code{"kd"} (KDTree),
or \code{"ball"} (BallTree). Tree methods use mlpack implementation but may be
biased with high missing value percentages. Default: \code{NULL}.}

\item{n_imp}{Integer. Number of multiple imputations to perform. Automatically
set to 1 if \code{n_pmm = -1}. Default: 1.}

\item{n_pmm}{Integer. Multiple imputation method control:
\itemize{
\item \code{-1}: Deterministic single imputation (default)
\item \verb{> 0}: Predictive Mean Matching using \code{n_pmm} closest donors
(recommended for MI. \code{8} is a good starting point.).
\item \code{0}: Bootstrap resampling from k-nearest neighbors
}}

\item{seed}{Integer. Random seed for multiple imputation. Default: 42.}

\item{output}{Character. File path stem for saving file-backed big.matrix results
(format: \code{"path/stem"}). If \code{NULL}, results are stored in memory. Recommended
for large data and multiple imputations.}

\item{overwrite}{Logical. Whether to overwrite existing files at \code{output} path.
Default: \code{FALSE}. See Notes for Windows.}

\item{...}{Currently not implemented.}
}
\value{
A list of length \code{n_imp} containing numeric matrices or \code{\link[bigmemory:big.matrix]{bigmemory::big.matrix()}}
objects (if \code{output} is specified) with the same dimensions as \code{obj}. Missing values
are imputed using k-NN for columns with missingness below \code{colmax}, and mean
imputation for remaining missing values if \code{post_imp = TRUE}.

Each list element represents an independent imputation. The only element of the
list when  \code{n_pmm == -1} is a single imputed matrix.
}
\description{
Imputes missing values in numeric matrices using the k-nearest neighbors algorithm
with a two-stage approach: k-NN imputation for columns with missingness below a
threshold, followed by optional mean imputation for remaining missing values.
}
\details{
This function performs \strong{column-wise} nearest neighbor calculations.

When \code{weighted = TRUE}, imputed values are computed as distance-weighted averages
where weights are inverse distances raised to the power of \code{dist_pow}. This gives
closer neighbors greater influence in the imputation process, which can increase
predictive performance.

The \code{tree} parameter enables faster neighbor search using spatial data structures
but requires pre-filling missing values with column means, which may introduce bias
in high-missingness data. Tree construction overhead may reduce performance for
low-dimensional data or small k values.
}
\note{
\strong{File-backed Storage}: For file-backed results using \code{output}, set
\code{options(bigmemory.allow.dimnames = TRUE)} before calling this function to preserve
dimnames, otherwise they can be manually restored from the original matrix with
\code{\link[=restore_dimnames]{restore_dimnames()}}.

\strong{File locks On Windows}: File-backed big.matrix objects hold file locks.
If you need to overwrite existing files, ensure previous results that points
to the same files are removed with \code{\link[=rm]{rm()}} and \code{\link[=gc]{gc()}} first.

\strong{Memory Considerations}: When \code{n_imp > 1} for large data, use \code{subset} to
specify only required columns and provide \code{output} for file-backed storage to
avoid memory constraints.
}
\section{Performance Optimization}{

\itemize{
\item \strong{Tree methods}: Only use when imputation runtime becomes prohibitive and missingness is low (<20\% missing)
\item \strong{File backing}: Use \code{output} parameter for \code{n_imp > 1} to avoid memory issues
\item \strong{Subset imputation}: Use \code{subset} parameter for efficiency when only specific columns need imputation
}
}

\examples{
data(khanmiss1)
sum(is.na(khanmiss1))

# Basic k-NN imputation (khanmiss1 has genes in rows, so transpose)
t_khanmiss1 <- t(khanmiss1)
result <- knn_imp(t_khanmiss1, k = 5)[[1]]
result

# Using weighted imputation with custom distance power multiple cores
imputed_weighted <- knn_imp(
  obj = t_khanmiss1,
  k = 5,
  cores = 4,
  weighted = TRUE,
  dist_pow = 2,
  method = "euclidean"
)
imputed_weighted

# Access the imputations just like a list
imputed_weighted[[1]][1:5, 1:5]

# Using only a subset of columns. Massive time saver
imputed_subset <- knn_imp(
  obj = t_khanmiss1,
  k = 5,
  cores = 4,
  weighted = TRUE,
  dist_pow = 2,
  subset = c("g189", "g299", "g361"),
  method = "euclidean"
)

# PMM imputation with 5 imputations and 5 donors. Increase `n_pmm` in real
# data to ensure realistic uncertainty quantification.
imputed_pmm <- knn_imp(
  obj = t_khanmiss1,
  k = 5,
  n_imp = 5,
  n_pmm = 5,
  output = withr::local_tempfile(),
  # Enables results as list of bigmatrix
  seed = 123
)
# The default of the bigmatrix package is to not allow dimnames so the output
# may lost the dimnames
imputed_pmm[[1]][, ][1:5, 1:5]

if (interactive()) {
  # But this can be reassigned after setting the options to be TRUE like so
  options(bigmemory.allow.dimnames = TRUE)
  restore_dimnames(imputed_pmm)
  imputed_pmm
}

length(imputed_pmm) # Returns 5 imputed data

# Bootstrap imputation for uncertainty injection
imputed_boot <- knn_imp(
  obj = t_khanmiss1,
  k = 3,
  n_imp = 5,
  n_pmm = 0,
  # n_pmm = 0 enables bootstrapping nearest neighbors
  seed = 123
)
imputed_boot
}
\references{
Robert Tibshirani, Trevor Hastie, Balasubramanian Narasimhan, and Gilbert Chu (2002).
Diagnosis of multiple cancer types by shrunken centroids of gene expression
PNAS 99: 6567-6572. Available at www.pnas.org
}
\seealso{
\code{\link[=SlideKnn]{SlideKnn()}}, \code{\link[=mean_impute_col]{mean_impute_col()}}, \code{\link[bigmemory:big.matrix]{bigmemory::big.matrix()}}, \code{\link[=restore_dimnames]{restore_dimnames()}}, \code{\link[=group_knn_imp]{group_knn_imp()}}
}
