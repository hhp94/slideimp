% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SlideKnn.R
\name{knn_imp}
\alias{knn_imp}
\title{K-Nearest Neighbor (k-NN) Imputation}
\usage{
knn_imp(
  obj,
  k,
  colmax = 0.9,
  rowmax = 0.9,
  method = c("euclidean", "manhattan", "impute.knn"),
  cores = 1,
  post_imp = TRUE,
  ...
)
}
\arguments{
\item{obj}{A numeric matrix with \strong{samples in rows} and \strong{features in columns}. See details.}

\item{k}{Integer specifying the number of nearest neighbors to use for imputation. Must be between 1 and (number of columns - 1).}

\item{colmax}{Numeric between 0 and 1 specifying the threshold proportion of missing values in a column above which the column is imputed using the mean instead of k-NN.}

\item{rowmax}{Numeric between 0 and 1 specifying the maximum allowable proportion of missing values in any row. If exceeded, the function stops with an error.}

\item{method}{Character string specifying the distance metric for k-NN. One of `"euclidean"`, `"manhattan"`, or `"impute.knn"`. Defaults to `"euclidean"`.}

\item{cores}{Integer specifying the number of cores to use for parallel computation of distances.}

\item{post_imp}{Logical; if TRUE (default), retry failed k-NN imputations with mean imputation.}

\item{...}{Not Implemented.}
}
\value{
A numeric matrix of the same dimensions as \code{obj} with missing values imputed.
}
\description{
This function imputes missing values in a numeric matrix using the k-Nearest
Neighbors algorithm. It follows a two-stage process. First, it imputes
columns with a proportion of missing values below `colmax` using k-NN.
Second, if requested, any remaining missing values are imputed using the column mean.
}
\details{
This implementation calculates the distances for neighbors column-wise. This is an
\strong{extremely} important detail. Outside of microarray data, most datasets have
people in columns and features (e.g., weight, height, etc.) in rows for imputation
However, in microarray data, genes or CpG sites for the same sample that are
spatially closer together carry mutual information, so you can place genes in columns
and samples in rows; the algorithm will then impute values based on nearby genes
for the same sample.

The distance calculation between columns for identifying nearest neighbors is
scaled based on the number of non-missing value pairs. Specifically, the
raw distance is penalized by scaling it up for columns that have fewer
overlapping observations. This penalizes distances for columns with very few
shared observations used for distance calculations. The
\code{impute.knn} method averages the distances over the number of matching positions,
so a column with only one matching value to calculate distance from might have a lower
raw distance than a column with many matched values. See also [stats::dist()].
}
\examples{
# See ?khanmiss1
data(khanmiss1)
sum(is.na(khanmiss1))

# Perform k-NN imputation. `khanmiss1` stores genes in the row so we have to t().
# set method to "impute.knn" to mimic how distant is scaled in impute::impute.knn.
imputed <- knn_imp(obj = t(khanmiss1), k = 3, colmax = 0.5, rowmax = 0.8, method = "euclidean")
imputed[1:5, 1:20]
sum(is.na(imputed))
}
