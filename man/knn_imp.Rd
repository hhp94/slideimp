% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SlideKnn.R
\name{knn_imp}
\alias{knn_imp}
\title{K-Nearest Neighbor Imputation for Missing Values}
\usage{
knn_imp(
  obj,
  k,
  colmax = 0.9,
  rowmax = 0.9,
  method = c("euclidean", "manhattan"),
  cores = 1,
  post_imp = TRUE,
  subset = NULL,
  weighted = FALSE,
  dist_pow = 1,
  tree = NULL,
  n_imp = 1,
  n_pmm = -1,
  seed = 42,
  output = NULL,
  overwrite = FALSE,
  ...
)
}
\arguments{
\item{obj}{A numeric matrix with \strong{samples in rows} and \strong{features in columns}.
Must have at least 1 row and 2 columns.}

\item{k}{Integer. Number of nearest neighbors for imputation. Must be between
1 and \code{n_feat - 1}. Default: 10.}

\item{colmax}{Numeric. Threshold proportion of missing values per column (0-1).
Columns exceeding this threshold are imputed using column means instead of
k-NN when \code{post_imp = TRUE}. Default: 0.9.}

\item{rowmax}{Numeric. Maximum allowable proportion of missing values per row
(0-1). Function stops with error if exceeded. Default: 0.9.}

\item{method}{Character. Distance metric for k-NN: \code{"euclidean"} or \code{"manhattan"}.
Default: \code{"euclidean"}.}

\item{cores}{Integer. Number of CPU cores for parallel distance computation.
Requires \code{\link[mirai:daemons]{mirai::daemons()}} setup for \code{cores} > 1. Default: 1.}

\item{post_imp}{Logical. Whether to impute remaining missing values with
column means after k-NN imputation. Default: \code{TRUE}.}

\item{subset}{Character vector of column names or integer vector of column
indices specifying which columns to impute.}

\item{weighted}{Logical. Whether to use distance-weighted mean for imputation.
If \code{FALSE}, uses simple mean of k nearest neighbors. Default: \code{FALSE}.}

\item{dist_pow}{Numeric. Positive value controlling distance penalty in weighted
imputation. Values < 1 apply softer penalty, 1 is linear, > 1 is harsher.
Only used when \code{weighted = TRUE}. Default: 1.}

\item{tree}{Character. k-NN search method: \code{NULL} (brute-force), \code{"kd"} (KDTree),
or \code{"ball"} (BallTree). Tree methods may introduce bias with high missingness.
Default: \code{NULL}.}

\item{n_imp}{Integer. Number of multiple imputations to perform. Automatically
set to 1 if \code{n_pmm = -1}. Default: 1.}

\item{n_pmm}{Integer. Multiple imputation method control:
\itemize{
\item \code{-1}: Deterministic single imputation (default)
\item \verb{> 0}: Predictive Mean Matching using \code{n_pmm} closest donors
(recommended for MI. \code{8} is a good starting point.).
\item \code{0}: Bootstrap resampling from k-nearest neighbors
}}

\item{seed}{Integer. Random seed for reproducible results in stochastic imputation
methods. Default: 42.}

\item{output}{Character. File path stem for saving file-backed big.matrix results
(format: \code{"path/stem"}). If \code{NULL}, results are stored in memory. Recommended
for large data and multiple imputations.}

\item{overwrite}{Logical. Whether to overwrite existing files at \code{output} path.
Default: \code{FALSE}. See Notes for Windows.}

\item{...}{Currently not implemented.}
}
\value{
A list of length \code{n_imp} containing numeric matrices or \code{\link[bigmemory:big.matrix]{bigmemory::big.matrix()}}
objects (if \code{output} is specified) with the same dimensions as \code{obj}. Missing values
are imputed using k-NN for columns with missingness below \code{colmax}, and mean
imputation for remaining missing values if \code{post_imp = TRUE}.

The list has class \code{"KnnImpList"} with attributes:
\itemize{
\item \code{rownames}: Original row names from input matrix
\item \code{colnames}: Original column names from input matrix
\item \code{subset}: Column indices that were processed for imputation
\item \code{ncol}: Number of columns in original matrix
}

Each list element represents an independent imputation. The only element of the
list when  \code{n_pmm == -1} is a single imputed matrix.
}
\description{
Imputes missing values in numeric matrices using the k-nearest neighbors algorithm
with a two-stage approach: k-NN imputation for columns with missingness below a
threshold, followed by optional mean imputation for remaining missing values.
}
\details{
This function performs \strong{column-wise} distance calculations, which is particularly
important for understanding its application domain. Unlike typical data where
samples are in columns and features in rows, this function is optimized for
intensive longitudinal data and epi-genomics where:
\itemize{
\item \strong{Samples are in rows} and \strong{features are in columns}
\item Spatially or temporally adjacent features carry mutual information
\item Imputation leverages nearby features within the same sample
}
\subsection{Weighting and Tree Methods}{

When \code{weighted = TRUE}, imputed values are computed as distance-weighted averages
where weights are inverse distances raised to the power of \code{dist_pow}. This gives
closer neighbors greater influence in the imputation process, which can increase
predictive performance.

The \code{tree} parameter enables faster neighbor search using spatial data structures
but requires pre-filling missing values with column means, which may introduce bias
in high-missingness data. Tree construction overhead may reduce performance for
low-dimensional data or small k values.
}
}
\note{
\strong{File-backed Storage}: For file-backed results using \code{output}, set
\code{options(bigmemory.allow.dimnames = TRUE)} before calling this function to preserve
dimnames, otherwise they can be manually restored from the original matrix with
\code{\link[=restore_dimnames]{restore_dimnames()}}.

\strong{File locks On Windows}: file-backed big.matrix objects hold file locks.
If you need to overwrite existing files, ensure previous results that points
to the same files are removed with \code{\link[=rm]{rm()}} and \code{\link[=gc]{gc()}} first.

\strong{Memory Considerations}: When \code{n_imp > 1} for large data, use \code{subset} to
specify only required columns and provide \code{output} for file-backed storage to
avoid memory constraints.
}
\section{Performance Optimization}{

\itemize{
\item \strong{Tree methods}: Only use when imputation runtime becomes prohibitive and missingness is low
\item \strong{KDTree} (\code{tree = "kd"}): Suitable for >5000 columns with <20\% missingness
\item \strong{BallTree} (\code{tree = "ball"}): For high-dimensional data or Manhattan distance
\item \strong{File backing}: Use \code{output} parameter for \code{n_imp > 1} to avoid memory issues
\item \strong{Subset imputation}: Consider \code{subset} parameter for efficiency when only specific columns need imputation
}
}

\examples{
# Quick start example
data(khanmiss1)
sum(is.na(khanmiss1))

# Basic k-NN imputation (khanmiss1 has genes in rows, so transpose)
t_khanmiss1 <- t(khanmiss1)
result <- knn_imp(t_khanmiss1, k = 5)[[1]]
sum(is.na(result)) # Should be 0

# Using weighted imputation with custom distance power multiple cores
imputed_weighted <- knn_imp(
  obj = t_khanmiss1,
  k = 5,
  cores = 4,
  weighted = TRUE,
  dist_pow = 2,
  method = "euclidean"
)

# Preview
imputed_weighted

# Access the imputations just like a list
imputed_weighted[[1]][1:5, 1:5]

# Using only a subset of columns. Massive time saver
imputed_subset <- knn_imp(
  obj = t_khanmiss1,
  k = 5,
  cores = 4,
  weighted = TRUE,
  dist_pow = 2,
  subset = c("g189", "g299", "g361"),
  method = "euclidean"
)

# PMM imputation with 5 imputations and 5 donors. Increase `n_pmm` in real
# data to ensure realistic uncertainty quantification.
imputed_pmm <- knn_imp(
  obj = t_khanmiss1,
  k = 5,
  n_imp = 5,
  n_pmm = 5,
  output = withr::local_tempfile(),
  # Enables results as list of bigmatrix
  seed = 123
)
# The default of the bigmatrix package is to not allow dimnames so the output
# may lost the dimnames
imputed_pmm[[1]][, ][1:5, 1:5]

if (interactive()) {
  # But this can be reassigned after setting the options to be TRUE like so
  options(bigmemory.allow.dimnames = TRUE)
  restore_dimnames(imputed_pmm)
}

length(imputed_pmm) # Returns 5 imputed data

# Bootstrap imputation for uncertainty injection
imputed_boot <- knn_imp(
  obj = t_khanmiss1,
  k = 3,
  n_imp = 5,
  n_pmm = 0,
  # n_pmm = 0 enables bootstrapping nearest neighbors
  seed = 123
)

length(imputed_boot) # Returns 5 imputed data

}
\references{
Robert Tibshirani, Trevor Hastie, Balasubramanian Narasimhan, and Gilbert Chu (2002).
Diagnosis of multiple cancer types by shrunken centroids of gene expression
PNAS 99: 6567-6572. Available at www.pnas.org
}
\seealso{
\code{\link[=SlideKnn]{SlideKnn()}}, \code{\link[=mean_impute_col]{mean_impute_col()}}, \code{\link[bigmemory:big.matrix]{bigmemory::big.matrix()}}, \code{\link[=restore_dimnames]{restore_dimnames()}}
}
