---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# slideimp

<!-- badges: start -->
[![R-CMD-check](https://github.com/hhp94/slideimp/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/hhp94/slideimp/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

`{slideimp}` is a lightweight R package for fast K-NN and PCA imputation of missing values in high-dimensional numeric matrices (such as intensive longitudinal or epigenetic data).

**Core functions**

* `knn_imp()`: Full-matrix K-NN imputation with multi-core parallelization, [`{mlpack}`](https://mlpack.org/) KD/Ball-Tree nearest neighbor implementation (for data with very low missing rates and extremely high dimensions), and optional subset imputation (ideal for epigenetic clock calculations).
* `pca_imp()`: Optimized version of [`missMDA::imputePCA()`](http://factominer.free.fr/missMDA/PCA.html) for high-dimensional numeric matrices.
* `slide_imp()`: Sliding window K-NN or PCA imputation for extremely high-dimensional numeric matrices with ordered features (by time or genomic position).
* `group_imp()`: Parallelizable group-wise (e.g., by chromosomes or column clusters) K-NN or PCA imputation with optional auxiliary features and group-wise parameters.
* `tune_imp()`: Parallelizable hyperparameter tuning with cross-validation; works with built-in or custom imputation functions.

## Installation

The stable version of `{slideimp}` can be installed from CRAN using:

```r
install.packages("slideimp")
```

You can install the development version of `{slideimp}` from [GitHub](https://github.com/hhp94/slideimp) with:

```r
install.packages("remotes")
remotes::install_github("hhp94/slideimp")
```

## Workflow
Let's simulate some DNA methylation (DNAm) microarray data from 2 chromosomes. All `{slideimp}` functions expect the input to be numeric matrices where variables are stored in the columns.

```{r}
library(slideimp)
# Simulate data from 2 chromosomes
set.seed(1234)
sim_obj <- sim_mat(m = 20, n = 50, perc_NA = 0.3, perc_col_NA = 1, nchr = 2)
# Here we see that variables are stored in rows
sim_obj$input[1:5, 1:5]

# So we t() to put the variables in columns
obj <- t(sim_obj$input)
```

Estimate the prediction accuracy of different methods and tune hyperparameters. Use the .f argument for custom function.

For custom functions, the `parameters` data.frame must include the columns corresponding to the arguments passed to the custom function. The custom function must accept `obj` as the first argument and return an object with the same dimensions.

We tune the results using 2 repeats (`rep = 2`) for illustration (increase in actual analyses).

```{r}
knn_params <- tibble::tibble(k = c(5, 20))
tune_knn <- tune_imp(obj, parameters = knn_params, cores = 2, rep = 2)
compute_metrics(tune_knn)
```

For PCA and custom functions, setup parallelization with `mirai::daemons(n_cores)`.
```{r, eval = F}
mirai::daemons(2)
pca_params <- tibble::tibble(ncp = c(1, 5))
tune_pca <- tune_imp(obj, parameters = pca_params, cores = 2, rep = 2)

# The parameters have `mean` and `sd` columns.
custom_params <- tibble::tibble(mean = 1, sd = 0)
# This function impute data with rnorm value of different `mean` and `sd`.
custom_function <- function(obj, mean, sd) {
  missing <- is.na(obj)
  obj[missing] <- rnorm(sum(missing), mean = mean, sd = sd)
  return(obj)
}
tune_custom <- tune_imp(obj, parameters = custom_params, .f = custom_function, cores = 2, rep = 2)

mirai::daemons(0) # Close daemons
```

Then, preferably perform imputation by group with `group_imp` if the variables can be meaningfully grouped (e.g., by chromosome). `group_imp` requires the `group` data frame, which contains 3 list columns: 1) `features`, 2) (optional) `aux`, and 3) (optional) `parameters`. Each element of the list column `features` is a character vector of variables to be imputed. Here, we have 2 chromosomes, so the `group` tibble has two groups (i.e., two rows). PCA imputation can be parallelized with `{mirai}` similar to `tune_imp`.

```{r, eval = F}
group_df <- tibble::tibble(
  features = lapply(c("chr1", "chr2"), \(x) subset(sim_obj$group_feature, group == x)$feature_id)
)
group_df
# We choose K-NN imputation, k = 5, from the `tune_imp` results.
group_imp(obj, group = group_df, k = 5)

mirai::daemons(2)
pca_results <- group_imp(obj, group = group_df, ncp = 3, cores = 2)
mirai::daemons(0)
```

Full matrix imputation can be performed using `knn_imp` or `pca_imp`.

```{r}
full_knn_results <- knn_imp(obj = obj, k = 5)
full_pca_results <- pca_imp(obj = obj, ncp = 5)
```

Sliding window imputation can be performed using `slide_imp`. DNAm WGBS/EM-seq data should be grouped by chromosome and converted into either beta or M values before sliding window imputation.

```{r}
chr1_beta <- t(sim_mat(m = 10, n = 2000, perc_NA = 0.3, perc_col_NA = 1, nchr = 1)$input)
dim(chr1_beta)
chr1_beta[1:5, 1:5]

# Tune the results using the first 50 variables
slide_knn_params <- tibble::tibble(n_feat = c(20, 50), n_overlap = 5, k = 10)
slide_knn_tune <- tune_imp(
  chr1_beta[, 1:50],
  parameters = slide_knn_params,
  .f = "slide_imp",
  cores = 2,
  rep = 2
)
# compute_metrics(slide_knn_tune)

# From the tune results, choose window size of 50, overlap of size 5 between windows,
# K-NN imputation using k = 10. Specify `ncp` for sliding window PCA imputation.
slide_imp(obj = chr1_beta, n_feat = 50, n_overlap = 5, k = 10, cores = 2, .progress = FALSE)
```
