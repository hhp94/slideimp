---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# slideimp

<!-- badges: start -->
[![R-CMD-check](https://github.com/hhp94/slideimp/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/hhp94/slideimp/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

`{slideimp}` is a lightweight R package for fast K-NN and PCA imputation of missing values in high-dimensional numeric matrices (e.g., epigenetic data or intensive longitudinal data).

**Core functions**

* `knn_imp()`: Full-matrix K-NN imputation with multi-core parallelization, [`{mlpack}`](https://mlpack.org/) KD/Ball-Tree nearest neighbor implementation (for data with very low missing rates and extremely high dimensions), and optional subset imputation (ideal for epigenetic clock calculations).
* `pca_imp()`: Optimized version of [`missMDA::imputePCA()`](http://factominer.free.fr/missMDA/PCA.html) for high-dimensional numeric matrices.
* `slide_imp()`: Sliding window K-NN or PCA imputation for extremely high-dimensional numeric matrices with ordered features (by time or genomic position).
* `group_imp()`: Parallelizable group-wise (e.g., by chromosomes or column clusters) K-NN or PCA imputation with optional auxiliary features and group-wise parameters.
* `tune_imp()`: Parallelizable hyperparameter tuning with repeated cross-validation; works with built-in or custom imputation functions.

## Installation

The stable version of `{slideimp}` can be installed from CRAN using:

```r
install.packages("slideimp")
```

You can install the development version of `{slideimp}` from [GitHub](https://github.com/hhp94/slideimp) with:

```r
pak::pkg_install("hhp94/slideimp")
```

## Workflow
Let's simulate some DNA methylation (DNAm) microarray data from 2 chromosomes. All `{slideimp}` functions expect the input to be a numeric matrix where variables are stored in the columns.

```{r}
library(slideimp)
# Simulate data from 2 chromosomes
set.seed(1234)
sim_obj <- sim_mat(m = 20, n = 50, perc_NA = 0.3, perc_col_NA = 1, nchr = 2)
# Here we see that variables are stored in rows
sim_obj$input[1:5, 1:5]

# So we t() to put the variables in columns
obj <- t(sim_obj$input)
```

We can optionally estimate the prediction accuracy of different methods and tune hyperparameters prior to imputation with `tune_imp()`.

For custom functions (`.f` argument), the `parameters` data.frame must include the columns corresponding to the arguments passed to the custom function. The custom function must accept `obj` as the first argument and return a matrix with the same dimensions as `obj`.

We tune the results using 2 repeats (`rep = 2`) for illustration (increase in actual analyses).

```{r}
knn_params <- tibble::tibble(k = c(5, 20))
# Parallelization is controlled by `cores` only for knn or slideimp knn
tune_knn <- tune_imp(obj, parameters = knn_params, cores = 2, rep = 2)
compute_metrics(tune_knn)
```

For PCA and custom functions, setup parallelization with `mirai::daemons()`.
```{r, eval = F}
mirai::daemons(2) # 2 Cores
# Note, for PCA and custom functions, cores is controlled by the `mirai::daemons()`
# and the `cores` argument is ignored.

# PCA imputation. Specified by the `ncp` column in the `pca_params` tibble.
pca_params <- tibble::tibble(ncp = c(1, 5))
tune_pca <- tune_imp(obj, parameters = pca_params, rep = 2)

# The parameters have `mean` and `sd` columns.
custom_params <- tibble::tibble(mean = 1, sd = 0)
# This function impute data with rnorm value of different `mean` and `sd`.
custom_function <- function(obj, mean, sd) {
  missing <- is.na(obj)
  obj[missing] <- rnorm(sum(missing), mean = mean, sd = sd)
  return(obj)
}
tune_custom <- tune_imp(obj, parameters = custom_params, .f = custom_function, rep = 2)

mirai::daemons(0) # Close daemons
```

Then, preferably perform imputation by group with `group_imp()` if the variables can be meaningfully grouped (e.g., by chromosomes).

- `group_imp()` allows imputation to be performed separately within defined groups, which is particularly useful when variables share biological or structural meaning (such as belonging to the same chromosome).
- `group_imp()` requires a `group` tibble with three list-columns:
  - `features`: **required** – a list-column where each element is a character vector of variable names to be imputed together.
  - `aux`: **optional** – auxiliary variables to include in each group.
  - `parameters`: **optional** – group-specific imputation parameters.
- In this example, we have data from 2 chromosomes so the `group` tibble should have **two rows** (one per chromosome), with the corresponding variables listed in the `features` column for each row.

PCA-based imputation with `group_imp()` can be parallelized using the `{mirai}` package, similar to how parallelization is done with `tune_imp()`.

```{r, eval = F}
group_df <- tibble::tibble(
  features = lapply(c("chr1", "chr2"), \(x) subset(sim_obj$group_feature, group == x)$feature_id)
)

# We choose K-NN imputation, k = 5, from the `tune_imp` results.
knn_group_results <- group_imp(obj, group = group_df, k = 5, cores = 2)

# Similar to `tune_imp`, parallelization is controlled by `mirai::daemons()`
mirai::daemons(2)
knn_group_results <- group_imp(obj, group = group_df, ncp = 3)
mirai::daemons(0)
```

Full matrix imputation can be performed using `knn_imp()` or `pca_imp()`.

```{r}
full_knn_results <- knn_imp(obj = obj, k = 5)
full_pca_results <- pca_imp(obj = obj, ncp = 5)
```

## Sliding Window Imputation
Sliding window imputation can be performed using `slide_imp()`. **Note:** DNAm WGBS/EM-seq data should be grouped by chromosomes and converted into either beta or M values before sliding window imputation. See vignette for more details.

```{r}
chr1_beta <- t(sim_mat(m = 10, n = 2000, perc_NA = 0.3, perc_col_NA = 1, nchr = 1)$input)
dim(chr1_beta)
chr1_beta[1:5, 1:5]

# From the tune results, choose window size of 50, overlap of size 5 between windows,
# K-NN imputation using k = 10. Specify `ncp` for sliding window PCA imputation.
slide_imp(obj = chr1_beta, n_feat = 50, n_overlap = 5, k = 10, cores = 2, .progress = FALSE)
```
