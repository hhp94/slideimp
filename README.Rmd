---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# slideimp

<!-- badges: start -->
[![R-CMD-check](https://github.com/hhp94/slide_imp/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/hhp94/slide_imp/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

`{slideimp}` is a lightweight R package for k-NN and PCA imputation of missing values in high-dimensional numeric matrices, such as those from intensively sampled longitudinal data or epigenetics. `knn_imp()` implements a full k-NN imputation. `pca_imp()` is a slightly optimized version of the [`missMDA::imputePCA()`](http://factominer.free.fr/missMDA/PCA.html) function. `slide_imp()` implements a sliding window k-NN or PCA imputation for data where features are ordered (e.g., by time or distance). `group_imp()` implements a group-wise imputation for data that can be broken into meaningful groups, like chromosomes or results of column clustering algorithms.

Key features include:

- **Sliding Window Imputation**: Break large data into overlapping windows for computationally feasible imputation while maintaining local structures (e.g., intensively sampled longitudinal data or epigenetics data).
- **Group Imputation**: Break large data into groups such as chromosomes or clusters identified by column clustering algorithms.
- **Full Matrix k-NN Imputation**: Standard k-NN for smaller data, with multi-core parallelization over columns with missing values.
- **Tree-Based k-NN**: Integration with [`{mlpack}`](https://www.mlpack.org/) for KD-Tree or Ball-Tree methods for imputation in high dimensions. Best when missing per feature is < 20% and dimension is very large.
- **Subset k-NN Imputation**: Only impute a subset of columns to save time. Important for applications such as epigenetics clocks calculations.
- **Full Matrix PCA Imputation**: From the [`{missMDA}`](http://factominer.free.fr/missMDA/index.html) package, optimized version of `imputePCA` (`pca_imp`) for numeric matrix.
- **Parameter Tuning**: Inject artificial NAs to evaluate and tune hyperparameters, with support for custom imputation functions.

## Installation

The stable version of `{slideimp}` can be installed from CRAN using:

```r
install.packages("slideimp")
```

You can install the development version of `{slideimp}` from [GitHub](https://github.com/hhp94/slideimp) with:

``` r
install.packages("remotes")
remotes::install_github("hhp94/slideimp")
```

## Full k-NN imputation `knn_imp()` and PCA imputation with `pca_imp()`
Use the workhorse function of the package, `knn_imp()` to perform full k-NN imputation.

```{r example}
library(slideimp)

data(khanmiss1)

# Transpose for samples in rows, features in columns
imputed_full <- knn_imp(t(khanmiss1), k = 3, method = "euclidean", cores = 1)
imputed_full
```

`knn_imp()` yields the same results as `impute::impute.knn()` without post imputation. `knn_imp()` is faster in larger data and is as fast in smaller data given `cores = 1`. `knn_imp()` scales well with multiple `cores`.
```{r}
library(bench)
library(ggplot2)

set.seed(1234)

mark(
  # Single Core
  knn_imp(t(khanmiss1), k = 3, method = "euclidean")[, ],
  # Multiple Cores
  knn_imp(t(khanmiss1), k = 3, cores = 4, method = "euclidean")[, ],
  # impute::impute.knn
  t(impute::impute.knn(khanmiss1, k = 3, maxp = nrow(khanmiss1))$data),
  # Ensure results are the same between function calls
  check = TRUE
) |>
  dplyr::mutate(expression = c("knn_1", "knn_4", "impute.knn_1")) |>
  dplyr::select(-dplyr::where(is.list))
```

Using tree-based k-NN with weighted imputation:
```{r}
imputed_tree <- knn_imp(
  t(khanmiss1),
  k = 5,
  tree = "kd", # KD-Tree via mlpack
  dist_pow = 2
)
imputed_tree
```

Similarly, `pca_imp()` is a slightly optimized version of `missMDA::imputePCA()` for numeric matrix.
```{r}
bench::mark(
  pca_imp(t(khanmiss1)[, 1:500], ncp = 2)[, ],
  missMDA::imputePCA(t(khanmiss1)[, 1:500], ncp = 2)$completeObs,
  check = TRUE
) |>
  dplyr::mutate(expression = c("pca_imp", "imputePCA")) |>
  dplyr::select(-dplyr::where(is.list))
```

## Sliding window k-NN and PCA imputation with `slide_imp()`
Epigenetic datasets such as WGBS or EM-seq are very spatially correlated, `slide_imp()` allows the imputation of the full epigenome with good accuracy and speed by limiting the neighbor search space to sliding windows.

Use k-NN by specifying `k`, PCA by specifying `ncp`. Only arguments applicable to each methods are applied.
```{r}
# Simulating WGBS data with 1000 CpGs and 10 samples
set.seed(1234)
beta_matrix <- t(sim_mat(m = 10, n = 1000, perc_NA = 0.3, perc_col_NA = 1)$input)
beta_matrix[1:10, 1:5]

# Sliding Window k-NN imputation by specifying `k`
knn_imputed <- slide_imp(beta_matrix, n_feat = 500, n_overlap = 10, k = 10)
knn_imputed

# Sliding Window PCA imputation by specifying `ncp`
pca_imputed <- slide_imp(beta_matrix, n_feat = 500, n_overlap = 10, ncp = 2)
pca_imputed
```

## Grouped imputation with `group_imp()`
Features can be grouped by chromosomes (in epigenetics) or by cluster memberships identified through column clustering algorithms, such as k-means. This significantly decreases imputation time and potentially increases imputation accuracy.

`group_imp()` requires the `group` data.frame (preferably a `tibble` for the handling of list columns), which is defined by two list-columns: `features` and `aux` (optional) where each row is a group. The `features` column includes all features to be imputed, while the `aux` columns contains features used to assist with imputation but excluded from the final results. For example, when imputing chrM, which may have only a few CpGs, random CpGs from other chromosomes can be included in the `aux` column to improve the quality of imputation.

Similar to `slide_imp()`, use k-NN by specifying `k`, PCA by specifying `ncp`.

```{r}
# Simulate data from 2 chromosomes
set.seed(1234)
to_test <- sim_mat(m = 20, n = 50, perc_NA = 0.3, perc_col_NA = 1, nchr = 2)

# `group_1` will be all the CpGs on Chr1. Same for `group_2`
group_1 <- subset(to_test$group_feature, group == "chr1")$feature_id
group_2 <- subset(to_test$group_feature, group == "chr2")$feature_id

# Impute only first 3 columns of group 1, the rest are aux. Group 2 does 4 features.
# Also optionally vary the parameters by group
knn_df <- tibble::tibble(
  features = list(group_1[1:3], group_2[1:4]),
  aux = list(group_1, group_2),
  parameters = list(list(k = 3, dist_pow = 0), list(k = 4, method = "manhattan"))
)

knn_df

# Run grouped imputation. t() to put features on the columns
obj <- t(to_test$input)
knn_grouped <- group_imp(obj, group = knn_df, k = 5)
knn_grouped

# Each group will be imputed with `pca_imp` and ncp = 2
pca_df <- tibble::tibble(
  features = list(group_1[1:3], group_2[1:4])
)

pca_grouped <- group_imp(obj, group = pca_df, ncp = 2)
pca_grouped
```

## Parameters Tuning with `tune_imp()`
Use `tune_imp()` to tune hyperparameters by injecting artificial NAs and evaluating imputation accuracy. This function supports built-in methods or custom functions. Available built-in methods
are "slide_imp", "knn_imp", and "pca_imp".

```{r}
# This tibble defines the hyperparameters to tune for. `knn_imp` requires `k`, but other parameters like `dist_pow` and `method` can also be tuned.
parameters <- dplyr::tibble(
  k = c(5, 10),
  method = "euclidean",
  dist_pow = c(2, 5)
)
parameters

obj_t <- t(khanmiss1)

# 3 repeats, each time inject 100 NAs
results <- tune_imp(obj_t, parameters, rep = 3, .f = "knn_imp", num_na = 100)

# Compute metrics with {yardstick}
library(yardstick)
met_set <- metric_set(mae, rmse, rsq)
results$metrics <- lapply(
  results$result,
  function(x) met_set(x, truth = truth, estimate = estimate)
)

head(
  dplyr::select(
    tidyr::unnest(dplyr::select(results, -result), cols = "metrics"),
    all_of(names(parameters)), contains(".")
  )
)
```

To tune a custom imputation function, a function has to take an numeric matrix `obj` as the first argument, return a matrix with the same dimension as `obj`, and parameters as arguments.
```{r}
# This custom function imputes NAs with rnorm values. First argument has to be `obj`, which is a numeric matrix. The returned object has to be the same dimension and data type as `obj`.
custom_imp <- function(obj, mean = 0, sd = 1) {
  na_pos <- is.na(obj)
  obj[na_pos] <- rnorm(sum(na_pos), mean = mean, sd = sd)
  return(obj)
}

# This tibble defines the hyperparameters grid similar to the built-in case.
parameters_custom <- dplyr::tibble(
  mean = c(0, 1),
  sd = c(1, 2)
)

# Similarly, use `{yardstick}` to get the prediction metrics
results_custom <- tune_imp(obj, parameters_custom, .f = custom_imp, rep = 2, num_na = 20)
results_custom$metrics <- lapply(
  results_custom$result,
  function(x) met_set(x, truth = truth, estimate = estimate)
)

head(
  dplyr::select(
    tidyr::unnest(dplyr::select(results_custom, -result), cols = "metrics"),
    dplyr::all_of(names(parameters_custom)), dplyr::contains(".")
  )
)
```

For more details, see the function documentation (e.g., `?slide_imp`, `?group_imp`, `?pca_imp`, `?knn_imp`, `?tune_imp`).
