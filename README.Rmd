---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# SlideKnn

<!-- badges: start -->
[![R-CMD-check](https://github.com/hhp94/SlideKnn/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/hhp94/SlideKnn/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

`{SlideKnn}` is an efficient R package for k-nearest neighbors (k-NN) imputation of missing values in high-dimensional numeric matrices, such as those from intensive longitudinal data or epigenetics. It introduces a sliding window approach to handle very large feature sets while preserving local structure, making it suitable for data where features are ordered (e.g., by time or distance).

The package builds on the proven k-NN algorithm (Bioconductor's [`{impute}`](https://www.bioconductor.org/packages/release/bioc/html/impute.html) package) but adds enhancements: parallelization for speed, tree-based methods for efficiency, weighted imputation, multiple imputation strategies, and built-in tuning tools. It's designed for matrices with samples in rows and features in columns.

Key features include:

- **Sliding Window k-NN Imputation**: Break large data into overlapping windows for computationally feasible imputation while maintaining local structures (e.g., intensively sampled longitudinal data or epigenetics data).
- **Full Matrix k-NN Imputation**: Standard k-NN for smaller data, with multi-core parallelization over columns with missing values.
- **Tree-Based k-NN**: Integration with [`{mlpack}`](https://www.mlpack.org/) for KD-Tree or Ball-Tree methods, accelerating imputation in high dimensions.
- **Subset Imputation**: Only impute a subset of columns to save time. Important for applications such as epigenetics clocks calculations.
- **Weighted Imputation**: Use inverse-distance weighting for more accurate averages, with tunable penalties.
- **Multiple Imputation**: Support for Predictive Mean Matching (PMM) or bootstrap resampling from nearest neighbors.
- **Fallback Imputation**: Optional post-k-NN mean imputation by column to handle remaining NAs.
- **Parameter Tuning**: Inject artificial NAs to evaluate and tune hyperparameters, with support for custom imputation functions.
- **Big Matrix Support**: Compatible with [`{bigmemory}`](https://doi.org/10.32614/CRAN.package.bigmemory) for file-backed matrices to handle massive data without loading everything into RAM.

## Installation

The stable version of `{SlideKnn}` can be installed from CRAN using:

```r
install.packages("SlideKnn")
```

You can install the development version of `{SlideKnn}` from [GitHub](https://github.com/hhp94/SlideKnn) with:

``` r
install.packages("remotes")
remotes::install_github("hhp94/SlideKnn")
```

## Example
### Features
Load the package and use the built-in `khanmiss1` data (see `?khanmiss1` for details). For full matrix k-NN imputation without sliding windows:

```{r example}
library(SlideKnn)

data(khanmiss1)
# Transpose for samples in rows, features in columns
imputed_full <- knn_imp(t(khanmiss1), k = 3, method = "euclidean", cores = 1)
imputed_full

sum(is.na(imputed_full[[1]]))
```

Yields the same results as `impute::impute.knn()`. `SlideKnn::knn_imp` is faster in larger data and almost as fast in smaller data given `cores = 1`. Scaling well with multiple `cores`.
```{r}
set.seed(1234)
obj_t <- t(khanmiss1)

bench::mark(
  # Single Core
  knn_imp(obj_t, k = 3, rowmax = 1, method = "euclidean")[[1]],
  # Multiple Cores
  knn_imp(obj_t, k = 3, rowmax = 1, cores = 4, method = "euclidean")[[1]],
  t(impute::impute.knn(khanmiss1, k = 3, rowmax = 1, maxp = nrow(khanmiss1))$data)
) |>
  dplyr::mutate(expression = c("knn_1", "knn_4", "impute.knn_1")) |>
  dplyr::select(-dplyr::where(is.list))
```

Sliding window k-NN imputation for epigenetics data with 1000 CpGs and 10 samples
```{r}
set.seed(1234)
beta_matrix <- t(sim_mat(m = 10, n = 1000, perc_NA = 0.3, perc_col_NA = 1)$input)
beta_matrix[1:10, 1:5]

imputed <- SlideKnn(beta_matrix, n_feat = 500, n_overlap = 10, k = 10)

imputed
sum(is.na(imputed[[1]][, ]))
```

Using tree-based k-NN with weighting and multiple imputation (PMM):
```{r}
imputed_tree <- knn_imp(
  t(khanmiss1),
  k = 5,
  tree = "kd", # KD-Tree via mlpack
  weighted = TRUE, # Inverse-distance weighting
  dist_pow = 2, # Harsher penalty for distant neighbors
  n_imp = 3, # 3 imputations
  n_pmm = 10 # PMM with 10 donors
)
imputed_tree
```

Optional simple mean imputation as a fallback or baseline that enables multi-step imputation strategies
```{r}
# Inject extra NA into simulated data to make k-NN fail for first imputation
set.seed(1234)
obj <- t(sim_mat(n = 1000, m = 100, perc_NA = 0.8, perc_col_NA = 1)$input)
# Step 1: Column-wise imputation (impute the features using neighbor features
# of the same person/sample). Disable fall back imputation with `post_imp = FALSE`
imputed_by_col <- knn_imp(obj, cores = 4, k = 10, post_imp = FALSE)
# Step 2: Then if values are still missing, impute by rows. (impute the same features
# using values from OTHER people/samples).
imputed_by_row <- knn_imp(t(imputed_by_col[[1]]), cores = 4, k = 10, post_imp = FALSE)
# Step 3: Lastly, impute by column mean for any remaining missing.
imputed_mean <- mean_impute_col(t(imputed_by_row[[1]]))
sum(is.na(imputed_mean))
```

### File-backed big.matrix
For very large matrices that don't fit in memory, use `{bigmemory}` to create file-backed objects. `SlideKnn` supports passing a `big.matrix` object or the path to its descriptor file. Specify `output` for the result to change the whole backend to using file-backed big.matrix as well to minimize memory at a cost of performance. 

**NOTE**: See `?restore_dimnames` if output's dimnames are stripped.

```{r}
library(bigmemory)

# IMPORTANT: Enable dimnames support for big.matrix objects
options(bigmemory.allow.dimnames = TRUE)

# Load example data
data(khanmiss1)
mat <- t(khanmiss1) # samples as rows, features as columns
temp_dir <- withr::local_tempdir()
```

### Create file-backed big.matrix
```{r}
# Convert t(khanmiss1) to big.matrix with backing files for large data
big_mat <- bigmemory::as.big.matrix(
  mat,
  type = "double",
  backingfile = "khan.bin",
  descriptorfile = "khan.desc",
  backingpath = temp_dir
)
```

### Method 1: Impute using big.matrix object
Impute a `bigmemory::big.matrix` and optionally save results to file-backed big.matrix
```{r}
imputed_obj <- SlideKnn(
  obj = big_mat,
  n_feat = 100,
  n_overlap = 10,
  k = 10,
  overwrite = TRUE, # Overwrite any existing results
  output = file.path(temp_dir, "imputed.bin")
)

# Access the imputed data (returns list of big.matrix objects)
sum(is.na(imputed_obj[[1]][, ])) # Check for remaining NAs
imputed_obj
```

### ⚠️ Regarding objects pointing to the same bigmemory matrices
On Windows, file-backed objects hold file locks. You MUST remove any variables that point to the same files before overwriting them. This only removes the R variables, not the files on disk.

In general, always remove references to big.matrix objects before attempting to overwrite or modify their backing files.
```{r, echo=TRUE, message=FALSE}
rm(imputed_obj)
invisible(gc(verbose = FALSE))  # Force garbage collection to release file handles
```

### Method 2: Impute using descriptor file path
Alternatively, pass descriptor file path instead of object. This is useful for distributed computing or when object isn't in memory.
```{r}
desc_path <- file.path(temp_dir, "khan.desc")

imputed_path <- SlideKnn(
  obj = desc_path, # Using path instead of object
  n_feat = 100,
  n_overlap = 10,
  k = 10,
  overwrite = TRUE,
  output = file.path(temp_dir, "imputed.bin")
)

imputed_path
```

## Parameter Tuning
Use `tune_imp()` to tune hyperparameters by injecting artificial NAs and evaluating imputation accuracy. It supports built-in methods or custom functions.

```{r}
parameters <- dplyr::tibble(
  k = c(5, 10),
  method = "euclidean",
  weighted = TRUE,
  dist_pow = c(2, 5),
  post_imp = TRUE
)
parameters

obj_t <- t(khanmiss1)

# 3 repeats, each time inject 100 NAs
results <- tune_imp(obj_t, parameters, rep = 3, .f = "knn_imp", num_na = 100)

# Compute metrics with {yardstick}
library(yardstick)
met_set <- metric_set(mae, rmse, rsq)
results$metrics <- lapply(results$result, function(x) met_set(x, truth = truth, estimate = estimate))
head(
  dplyr::select(
    tidyr::unnest(dplyr::select(results, -result), cols = "metrics"),
    all_of(names(parameters)), contains(".")
  )
)
```

Tuning a custom imputation function:
```{r}
# This custom function imputes NAs with rnorm values
custom_imp <- function(obj, mean = 0, sd = 1) {
  na_pos <- is.na(obj)
  obj[na_pos] <- rnorm(sum(na_pos), mean = mean, sd = sd)
  return(obj)
}

parameters_custom <- dplyr::tibble(
  mean = c(0, 1),
  sd = c(1, 2)
)

results_custom <- tune_imp(obj, parameters_custom, .f = custom_imp, rep = 2, num_na = 20)
results_custom$metrics <- lapply(results_custom$result, function(x) met_set(x, truth = truth, estimate = estimate))
head(
  dplyr::select(
    tidyr::unnest(dplyr::select(results_custom, -result), cols = "metrics"),
    dplyr::all_of(names(parameters_custom)), dplyr::contains(".")
  )
)
```

For more details, see the function documentation (e.g., `?SlideKnn`, `?knn_imp`, `?tune_imp`).

# Developer notes for [`{mlpack}`](https://www.mlpack.org/)

`{mlpack}` is an awesome library and works seamlessly with integration in R. For other developers who are looking to integrate `{mlpack}` into their own work, make sure to structure the .cpp file as follows. Most importantly is the inclusion of `<mlpack.h>` first before including any other `mlpack` headers. This appropriately directs the output of `std::cout` and `std::cerr` to R and won't trip `R CMD check` (i.e., `'_ZSt4cerr', possibly from 'std::cerr' (C++)` or `'_ZSt4cout', possibly from 'std::out' (C++)`). Full implementation is found under `src/impute_knn_mlpack.cpp`. I would like to thank the developers and the community for the maintenance and development of `mlpack`. I would like to especially thank Dirk Eddelbuettel for his development of the R + C++ environment and guidance throughout the development of this package.

```cpp
// [[Rcpp::depends(mlpack, RcppArmadillo)]]
#include <mlpack.h>
#include "imputed_value.h"
#include <mlpack/methods/neighbor_search/neighbor_search.hpp>
#include <RcppArmadillo.h>
```
